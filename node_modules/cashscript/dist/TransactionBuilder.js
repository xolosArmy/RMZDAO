import { binToHex, decodeTransaction, encodeTransaction, hexToBin, } from '@bitauth/libauth';
import delay from 'delay';
import { isUnlockableUtxo, } from './interfaces.js';
import { cashScriptOutputToLibauthOutput, createOpReturnOutput, validateOutput, } from './utils.js';
import { FailedTransactionError } from './Errors.js';
const DEFAULT_SEQUENCE = 0xfffffffe;
export class TransactionBuilder {
    constructor(options) {
        this.inputs = [];
        this.outputs = [];
        this.provider = options.provider;
    }
    addInput(utxo, unlocker, options) {
        this.inputs.push({ ...utxo, unlocker, options });
        return this;
    }
    addInputs(utxos, unlocker, options) {
        if ((!unlocker && utxos.some((utxo) => !isUnlockableUtxo(utxo)))
            || (unlocker && utxos.some((utxo) => isUnlockableUtxo(utxo)))) {
            throw new Error('Either all UTXOs must have an individual unlocker specified, or no UTXOs must have an individual unlocker specified and a shared unlocker must be provided');
        }
        if (!unlocker) {
            this.inputs = this.inputs.concat(utxos);
            return this;
        }
        this.inputs = this.inputs.concat(utxos.map(((utxo) => ({ ...utxo, unlocker, options }))));
        return this;
    }
    addOutput(output) {
        return this.addOutputs([output]);
    }
    addOutputs(outputs) {
        outputs.forEach(validateOutput);
        this.outputs = this.outputs.concat(outputs);
        return this;
    }
    // TODO: allow uint8array for chunks
    addOpReturnOutput(chunks) {
        this.outputs.push(createOpReturnOutput(chunks));
        return this;
    }
    setLocktime(locktime) {
        this.locktime = locktime;
        return this;
    }
    setMaxFee(maxFee) {
        this.maxFee = maxFee;
        return this;
    }
    checkMaxFee() {
        if (!this.maxFee)
            return;
        const totalInputAmount = this.inputs.reduce((total, input) => total + input.satoshis, 0n);
        const totalOutputAmount = this.outputs.reduce((total, output) => total + output.amount, 0n);
        const fee = totalInputAmount - totalOutputAmount;
        if (fee > this.maxFee) {
            throw new Error(`Transaction fee of ${fee} is higher than max fee of ${this.maxFee}`);
        }
    }
    build() {
        this.checkMaxFee();
        const inputs = this.inputs.map((utxo) => ({
            outpointIndex: utxo.vout,
            outpointTransactionHash: hexToBin(utxo.txid),
            sequenceNumber: utxo.options?.sequence ?? DEFAULT_SEQUENCE,
            unlockingBytecode: new Uint8Array(),
        }));
        const outputs = this.outputs.map(cashScriptOutputToLibauthOutput);
        const transaction = {
            inputs,
            locktime: this.locktime,
            outputs,
            version: 2,
        };
        // Generate source outputs from inputs (for signing with SIGHASH_UTXOS)
        const sourceOutputs = this.inputs.map((input) => {
            const sourceOutput = {
                amount: input.satoshis,
                to: input.unlocker.generateLockingBytecode(),
                token: input.token,
            };
            return cashScriptOutputToLibauthOutput(sourceOutput);
        });
        const inputScripts = this.inputs.map((input, inputIndex) => (input.unlocker.generateUnlockingBytecode({ transaction, sourceOutputs, inputIndex })));
        inputScripts.forEach((script, i) => {
            transaction.inputs[i].unlockingBytecode = script;
        });
        return binToHex(encodeTransaction(transaction));
    }
    async send(raw) {
        const tx = this.build();
        try {
            const txid = await this.provider.sendRawTransaction(tx);
            return raw ? await this.getTxDetails(txid, raw) : await this.getTxDetails(txid);
        }
        catch (e) {
            const reason = e.error ?? e.message;
            throw new FailedTransactionError(reason);
        }
    }
    async getTxDetails(txid, raw) {
        for (let retries = 0; retries < 1200; retries += 1) {
            await delay(500);
            try {
                const hex = await this.provider.getRawTransaction(txid);
                if (raw)
                    return hex;
                const libauthTransaction = decodeTransaction(hexToBin(hex));
                return { ...libauthTransaction, txid, hex };
            }
            catch (ignored) {
                // ignored
            }
        }
        // Should not happen
        throw new Error('Could not retrieve transaction details for over 10 minutes');
    }
}
//# sourceMappingURL=TransactionBuilder.js.map