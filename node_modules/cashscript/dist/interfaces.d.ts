import { type Transaction } from '@bitauth/libauth';
import type { NetworkProvider } from './network/index.js';
import type SignatureTemplate from './SignatureTemplate.js';
export interface Utxo {
    txid: string;
    vout: number;
    satoshis: bigint;
    token?: TokenDetails;
}
export interface UnlockableUtxo extends Utxo {
    unlocker: Unlocker;
    options?: InputOptions;
}
export declare function isUnlockableUtxo(utxo: Utxo): utxo is UnlockableUtxo;
export interface InputOptions {
    sequence?: number;
}
export interface GenerateUnlockingBytecodeOptions {
    transaction: Transaction;
    sourceOutputs: LibauthOutput[];
    inputIndex: number;
}
export interface Unlocker {
    generateLockingBytecode: () => Uint8Array;
    generateUnlockingBytecode: (options: GenerateUnlockingBytecodeOptions) => Uint8Array;
}
export interface UtxoP2PKH extends Utxo {
    template: SignatureTemplate;
}
export declare function isUtxoP2PKH(utxo: Utxo): utxo is UtxoP2PKH;
export interface Recipient {
    to: string;
    amount: bigint;
    token?: TokenDetails;
}
export interface Output {
    to: string | Uint8Array;
    amount: bigint;
    token?: TokenDetails;
}
export interface TokenDetails {
    amount: bigint;
    category: string;
    nft?: {
        capability: 'none' | 'mutable' | 'minting';
        commitment: string;
    };
}
export interface NftObject {
    category: string;
    capability: 'none' | 'mutable' | 'minting';
    commitment: string;
}
export interface LibauthOutput {
    lockingBytecode: Uint8Array;
    valueSatoshis: bigint;
    token?: LibauthTokenDetails;
}
export interface LibauthTokenDetails {
    amount: bigint;
    category: Uint8Array;
    nft?: {
        capability: 'none' | 'mutable' | 'minting';
        commitment: Uint8Array;
    };
}
export declare enum SignatureAlgorithm {
    ECDSA = 0,
    SCHNORR = 1
}
export declare enum HashType {
    SIGHASH_ALL = 1,
    SIGHASH_NONE = 2,
    SIGHASH_SINGLE = 3,
    SIGHASH_UTXOS = 32,
    SIGHASH_ANYONECANPAY = 128
}
export declare const Network: {
    MAINNET: "mainnet";
    TESTNET3: "testnet3";
    TESTNET4: "testnet4";
    CHIPNET: "chipnet";
    MOCKNET: "mocknet";
    REGTEST: "regtest";
};
export type Network = (typeof Network)[keyof typeof Network];
export interface TransactionDetails extends Transaction {
    txid: string;
    hex: string;
}
export interface ContractOptions {
    provider?: NetworkProvider;
    addressType?: AddressType;
}
export type AddressType = 'p2sh20' | 'p2sh32';
