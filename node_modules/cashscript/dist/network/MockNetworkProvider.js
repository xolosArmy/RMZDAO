import { binToHex, hexToBin } from '@bitauth/libauth';
import { sha256 } from '@cashscript/utils';
import { Network } from '../interfaces.js';
import { addressToLockScript, randomUtxo } from '../utils.js';
// redeclare the addresses from vars.ts instead of importing them
const aliceAddress = 'bchtest:qpgjmwev3spwlwkgmyjrr2s2cvlkkzlewq62mzgjnp';
const bobAddress = 'bchtest:qz6q5gqnxdldkr07xpls5474mmzmlesd6qnux4skuc';
const carolAddress = 'bchtest:qqsr7nqwe6rq5crj63gy5gdqchpnwmguusmr7tfmsj';
export default class MockNetworkProvider {
    constructor() {
        this.utxoMap = {};
        this.transactionMap = {};
        this.network = Network.MOCKNET;
        for (let i = 0; i < 3; i += 1) {
            this.addUtxo(aliceAddress, randomUtxo());
            this.addUtxo(bobAddress, randomUtxo());
            this.addUtxo(carolAddress, randomUtxo());
        }
    }
    async getUtxos(address) {
        const lockingBytecode = binToHex(addressToLockScript(address));
        return this.utxoMap[lockingBytecode] ?? [];
    }
    async getBlockHeight() {
        return 133700;
    }
    async getRawTransaction(txid) {
        return this.transactionMap[txid];
    }
    async sendRawTransaction(txHex) {
        const transactionBin = hexToBin(txHex);
        const txid = binToHex(sha256(sha256(transactionBin)).reverse());
        this.transactionMap[txid] = txHex;
        return txid;
    }
    addUtxo(address, utxo) {
        const lockingBytecode = binToHex(addressToLockScript(address));
        if (!this.utxoMap[lockingBytecode]) {
            this.utxoMap[lockingBytecode] = [];
        }
        this.utxoMap[lockingBytecode].push(utxo);
    }
    reset() {
        this.utxoMap = {};
        this.transactionMap = {};
    }
}
//# sourceMappingURL=MockNetworkProvider.js.map