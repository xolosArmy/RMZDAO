import { base64ToBin } from "@bitauth/libauth";
import { OpReturnData, SendRequest, TokenSendRequest, } from "../wallet/model.js";
export function asSendRequestObject(requests) {
    let resp = [];
    if (Array.isArray(requests)) {
        requests.forEach((r) => {
            // the SendRequestArray[] case
            if (Array.isArray(r)) {
                if (r[0] === "OP_RETURN") {
                    // ['OP_RETURN', Buffer.new('MEMO\x10')],
                    resp.push(OpReturnData.from(r[1]));
                }
                else if (r[0] === "OP_RETURNB64") {
                    resp.push(OpReturnData.fromBuffer(Buffer.from(base64ToBin(r[1]))));
                }
                else {
                    // ['cashaddr', 120, 'sats'],
                    resp.push(new SendRequest({
                        cashaddr: r[0],
                        value: r[1],
                        unit: r[2],
                    }));
                }
            }
            else {
                // SendRequest | TokenSendRequest | OpReturnRequest case
                resp.push(convertToClass(r));
            }
        });
    }
    else {
        // the SendRequest | OpReturnData object case
        resp.push(convertToClass(requests));
    }
    return resp;
}
function convertToClass(object) {
    if (object.hasOwnProperty("unit")) {
        return new SendRequest(object);
    }
    else if (object.hasOwnProperty("tokenId")) {
        return new TokenSendRequest(object);
    }
    else if (object.hasOwnProperty("buffer")) {
        return OpReturnData.fromBuffer(object.buffer);
    }
    // endcoding in REST
    else if (object.hasOwnProperty("dataString")) {
        return OpReturnData.fromString(object.dataString);
    }
    else if (object.hasOwnProperty("dataBuffer")) {
        return OpReturnData.fromBuffer(Buffer.from(base64ToBin(object.dataBuffer)));
    }
    throw new Error("Unsupported send object");
}
//# sourceMappingURL=asSendRequestObject.js.map