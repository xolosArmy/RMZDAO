import { Network } from "../interface.js";
import BigNumber from "bignumber.js";
import { _emptyTokenBalance, } from "./SlpProvider.js";
import axios from "axios";
import { btoa } from "../util/base64.js";
//import EventSource from "../../polyfill/eventsource.js";
import EventSource from "../util/eventsource.js";
import { getRuntimePlatform, RuntimePlatform, } from "../util/getRuntimePlatform.js";
export class GsppProvider {
    constructor(network = Network.MAINNET) {
        this.network = network;
        this.servers = { ...GsppProvider.defaultServers };
        this.caching = false;
        if (getRuntimePlatform() === RuntimePlatform.node) {
            if (process.env.GSPP_MAINNET_DATA)
                this.servers.mainnet.dataSource = process.env.GSPP_MAINNET_DATA;
            if (process.env.GSPP_MAINNET_EVENTS)
                this.servers.mainnet.eventSource = process.env.GSPP_MAINNET_EVENTS;
            if (process.env.GSPP_TESTNET_DATA)
                this.servers.testnet.dataSource = process.env.GSPP_TESTNET_DATA;
            if (process.env.GSPP_TESTNET_EVENTS)
                this.servers.testnet.eventSource = process.env.GSPP_TESTNET_EVENTS;
            if (process.env.GSPP_REGTEST_DATA)
                this.servers.regtest.dataSource = process.env.GSPP_REGTEST_DATA;
            if (process.env.GSPP_REGTEST_EVENTS)
                this.servers.regtest.eventSource = process.env.GSPP_REGTEST_EVENTS;
        }
    }
    // all oupoints, including mint batons
    async SlpOutpoints(slpaddr) {
        return (await this.GsppQuery({ cashaddr: slpaddr }, "v1/graphsearch/slpoutpoints")).outpoints;
    }
    // all utxos, including mint batons
    async SlpUtxos(slpaddr) {
        const response = (await this.GsppQuery({ cashaddr: slpaddr }, "v1/graphsearch/slputxos")).utxos;
        if (!response) {
            return [];
        }
        return _convertUtxoBigNumbers(response);
    }
    // safe-spendable token utxos, without baton
    async SlpSpendableUtxos(slpaddr, tokenId) {
        return (await this.SlpUtxos(slpaddr)).filter((val) => val.isBaton === false && (tokenId ? val.tokenId === tokenId : true));
    }
    // token mint baton utxos
    async SlpBatonUtxos(slpaddr, tokenId) {
        return (await this.SlpUtxos(slpaddr)).filter((val) => val.isBaton === true && (tokenId ? val.tokenId === tokenId : true));
    }
    // look up the token information
    async SlpTokenInfo(tokenId) {
        const info = (await this.GsppQuery({ tokenId: tokenId }, "v1/graphsearch/slptokeninfo"));
        return _convertSlpTokenInfo(info);
    }
    // get all token balances
    async SlpAllTokenBalances(slpaddr) {
        return _convertBalanceBigNumbers(((await this.GsppQuery({ cashaddr: slpaddr }, "v1/graphsearch/slpalltokenbalances")).balances || []));
    }
    // get specific token balance
    async SlpTokenBalance(slpaddr, tokenId) {
        const response = await this.GsppQuery({ cashaddr: slpaddr, tokenId: tokenId }, "v1/graphsearch/slptokenbalance");
        if (!response) {
            return _emptyTokenBalance(tokenId);
        }
        const balances = _convertBalanceBigNumbers([response]);
        if (balances[0].value.isZero()) {
            return _emptyTokenBalance(tokenId);
        }
        return balances[0];
    }
    // get all slp transactions of this address
    async SlpAddressTransactionHistory(_slpaddr, _tokenId, _limit = 100, _skip = 0) {
        throw "Not implemented";
    }
    // waits for next slp transaction to appear in mempool, code execution is halted
    async SlpWaitForTransaction(slpaddr, tokenId) {
        return new Promise(async (resolve) => {
            const cancelFn = this.SlpWatchTransactions(async (tx) => {
                await cancelFn();
                resolve(tx);
            }, slpaddr, tokenId);
        });
    }
    // waits for a certain slp token balance to be available in this wallet, code execution is halted
    async SlpWaitForBalance(value, slpaddr, tokenId) {
        return new Promise((resolve) => {
            const cancelFn = this.SlpWatchBalance(async (balance) => {
                if (balance.value.isGreaterThanOrEqualTo(new BigNumber(value))) {
                    await cancelFn();
                    resolve(balance);
                }
            }, slpaddr, tokenId);
        });
    }
    // sets up a callback to be executed each time the token balance of the wallet is changed
    SlpWatchBalance(callback, slpaddr, tokenId) {
        return this.SlpWatchTransactions(async () => {
            const balance = await this.SlpTokenBalance(slpaddr, tokenId);
            callback(balance);
        }, slpaddr, tokenId);
    }
    // sets up a callback to be executed each time a new transaction associated with this wallet's address is entering the mempool
    SlpWatchTransactions(callback, slpaddr, tokenId) {
        const eventSource = this.SlpSocketEventSource({
            query: { slpaddr, tokenId },
        });
        const cancelFn = async () => {
            eventSource.close();
        };
        eventSource.addEventListener("message", async (txEvent) => {
            const data = JSON.parse(txEvent.data);
            if (data.type === "rawtx") {
                const tx = {
                    tx_hash: data.data.txHash,
                    height: 0,
                    details: data.data,
                };
                callback(tx);
            }
        }, false);
        return cancelFn;
    }
    GsppQuery(queryObject, endpoint) {
        if (this.caching) {
            axiosInstance.defaults.headers = {};
        }
        else {
            axiosInstance.defaults.headers = noCacheHeaders;
        }
        // console.log(queryObject, endpoint);
        return new Promise((resolve, reject) => {
            const url = `${this.servers[this.network].dataSource}/${endpoint}`;
            fetch_retry(url, queryObject)
                .then((response) => {
                resolve(response.data);
            })
                .catch((error) => {
                if (error.isAxiosError) {
                    // console.trace(JSON.stringify(error, null, 2));
                    reject(error.response.data);
                }
                reject(error);
            });
        });
    }
    SlpSocketEventSource(queryObject) {
        const url = `${this.servers[this.network].eventSource}/s/${B64QueryString(queryObject)}`;
        return new EventSource(url);
    }
}
GsppProvider.defaultServers = {
    mainnet: {
        dataSource: "https://gs.fountainhead.cash",
        eventSource: "https://slpsocket.fountainhead.cash",
    },
    testnet: {
        dataSource: "https://gs-testnet.fountainhead.cash",
        eventSource: "https://slpsocket-testnet.fountainhead.cash",
    },
    regtest: {
        dataSource: "http://localhost:12400",
        eventSource: "http://localhost:12401",
    },
};
const noCacheHeaders = {
    "Cache-Control": "no-cache",
    Pragma: "no-cache",
    Expires: "0",
};
const axiosInstance = axios.create({
    headers: noCacheHeaders,
});
const fetch_retry = (url, data = {}, n = 1) => axiosInstance.post(url, data).catch(function (error) {
    if (n === 0) {
        throw error;
    }
    return new Promise((resolve) => {
        setTimeout(() => resolve(fetch_retry(url, data, n - 1)), 1000);
    });
});
const B64QueryString = function (queryObject) {
    if (!queryObject || !Object.keys(queryObject).length) {
        throw new Error("Empty query");
    }
    return btoa(JSON.stringify(queryObject));
};
export function _convertBalanceBigNumbers(balances) {
    balances.forEach((val) => (val.value = new BigNumber(val.value).shiftedBy(-1 * val.decimals)));
    return balances;
}
export function _convertUtxoBigNumbers(utxos) {
    utxos.forEach((val) => {
        val.value = new BigNumber(val.value).shiftedBy(-1 * val.decimals);
        val.satoshis = Number(val.satoshis);
    });
    return utxos;
}
export function _convertSlpTokenInfo(tokenInfo) {
    if (!tokenInfo)
        return tokenInfo;
    tokenInfo.initialAmount = new BigNumber(tokenInfo.initialAmount).shiftedBy(-1 * tokenInfo.decimals);
    tokenInfo.parentTokenId = tokenInfo.groupId;
    return tokenInfo;
}
//# sourceMappingURL=GsppProvider.js.map