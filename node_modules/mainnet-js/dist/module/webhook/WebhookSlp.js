import { toSlpAddress } from "../util/bchaddr.js";
import { Wallet } from "../wallet/Wif.js";
import { Webhook, WebhookRecurrence, WebhookType } from "./Webhook.js";
import WebhookWorker from "./WebhookWorker.js";
export class WebhookSlp extends Webhook {
    constructor(hook) {
        super(hook);
        Object.assign(this, hook);
        this.cashaddr = toSlpAddress(this.cashaddr);
    }
    async start() {
        const webhookCallback = async (rawTx) => {
            let result = false;
            if ("_id" in rawTx.details) {
                result = await this.slpDbHandler(rawTx);
            }
            else {
                result = await this.gsppHandler(rawTx);
            }
            if (result && this.recurrence === WebhookRecurrence.once) {
                // we have to notify the worker about end of life
                await (await WebhookWorker.instance()).stopHook(this);
                await this.destroy();
            }
        };
        this.callback = webhookCallback;
        this.wallet = await Wallet.fromSlpaddr(this.cashaddr);
        this.cancelFn = this.wallet.slp.watchTransactions(webhookCallback, this.tokenId);
    }
    async slpDbHandler(rawTx) {
        let result = false;
        const txDirection = this.type;
        const details = rawTx.details;
        if (this.type === WebhookType.slpTransactionInOut) {
            result = await this.post({
                direction: txDirection,
                data: rawTx,
            });
        }
        else if (this.type === WebhookType.slpTransactionIn &&
            details.out.findIndex((val) => val.e.a === this.cashaddr) > -1) {
            result = await this.post({
                direction: txDirection,
                data: rawTx,
            });
        }
        else if (this.type === WebhookType.slpTransactionOut &&
            details.in.findIndex((val) => val.e.a === this.cashaddr) > -1) {
            result = await this.post({
                direction: txDirection,
                data: rawTx,
            });
        }
        else if (this.type === WebhookType.slpBalance) {
            const balance = this.wallet.slp.getBalance(this.tokenId);
            result = await this.post({
                direction: txDirection,
                data: balance,
            });
        }
        return result;
    }
    async gsppHandler(rawTx) {
        let result = false;
        const txDirection = this.type;
        const details = rawTx.details;
        if (this.type === WebhookType.slpTransactionInOut) {
            result = await this.post({
                direction: txDirection,
                data: rawTx,
            });
        }
        else if (this.type === WebhookType.slpTransactionIn &&
            details.outputs.findIndex((val) => val === this.cashaddr) > -1) {
            result = await this.post({
                direction: txDirection,
                data: rawTx,
            });
        }
        else if (this.type === WebhookType.slpTransactionOut &&
            details.inputs.findIndex((val) => val === this.cashaddr) > -1) {
            result = await this.post({
                direction: txDirection,
                data: rawTx,
            });
        }
        else if (this.type === WebhookType.slpBalance) {
            const balance = this.wallet.slp.getBalance(this.tokenId);
            result = await this.post({
                direction: txDirection,
                data: balance,
            });
        }
        return result;
    }
    async stop() {
        await this.cancelFn();
    }
}
//# sourceMappingURL=WebhookSlp.js.map