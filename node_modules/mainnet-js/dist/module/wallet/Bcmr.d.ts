import { Transaction } from "@bitauth/libauth";
import { Network, TxI } from "../interface.js";
import { ElectrumRawTransaction } from "../network/interface.js";
import { IdentitySnapshot, Registry } from "./bcmr-v2.schema.js";
export interface AuthChainElement {
    txHash: string;
    contentHash: string;
    uris: string[];
    httpsUrl: string;
}
export declare type AuthChain = AuthChainElement[];
export declare class BCMR {
    static metadataRegistries: Registry[];
    static getRegistries(): Registry[];
    static resetRegistries(): void;
    /**
     * fetchMetadataRegistry Fetch the BCMR registry JSON file from a remote URI, optionally verifying its content hash
     *
     * @param  {string} uri URI of the registry to fetch from
     * @param  {string?} contentHash SHA256 hash of the resource the `uri` parameter points at.
     * If specified, calculates the hash of the data fetched from `uri` and matches it with provided one.
     * Yields an error upon mismatch.
     *
     * @returns {Registry} resolved registry
     */
    static fetchMetadataRegistry(uri: string, contentHash?: string): Promise<Registry>;
    /**
     * addMetadataRegistry Add the metadata registry to the list of tracked registries
     *
     * @param  {Registry} registry Registry object per schema specification, see https://raw.githubusercontent.com/bitjson/chip-bcmr/master/bcmr-v1.schema.json
     *
     */
    static addMetadataRegistry(registry: Registry): void;
    /**
     * addMetadataRegistryFromUri Add the metadata registry by fetching a JSON file from a remote URI, optionally verifying its content hash
     *
     * @param  {string} uri URI of the registry to fetch from
     * @param  {string?} contentHash SHA256 hash of the resource the `uri` parameter points at.
     * If specified, calculates the hash of the data fetched from `uri` and matches it with provided one.
     * Yields an error upon mismatch.
     *
     */
    static addMetadataRegistryFromUri(uri: string, contentHash?: string): Promise<void>;
    static makeAuthChainElement(rawTx: ElectrumRawTransaction | Transaction, hash: string): AuthChainElement;
    /**
     * buildAuthChain Build an authchain - Zeroth-Descendant Transaction Chain, refer to https://github.com/bitjson/chip-bcmr#zeroth-descendant-transaction-chains
     * The authchain in this implementation is specific to resolve to a valid metadata registry
     *
     * @param  {string} options.transactionHash (required) transaction hash from which to build the auth chain
     * @param  {Network?} options.network (default=mainnet) network to query the data from
     * @param  {boolean?} options.resolveBase (default=false) boolean flag to indicate that autchain building should resolve and verify elements back to base or be stopped at this exact chain element
     * @param  {boolean?} options.followToHead (default=true) boolean flag to indicate that autchain building should progress to head or be stopped at this exact chain element
     * @param  {ElectrumRawTransaction?} options.rawTx cached raw transaction obtained previously, spares a Fulcrum call
     * @param  {TxI[]?} options.historyCache cached address history to be reused if authchain building proceeds with the same address, spares a flurry of Fulcrum calls
     *
     * @returns {AuthChain} returns the resolved authchain
     */
    static buildAuthChain(options: {
        transactionHash: string;
        network?: Network;
        resolveBase?: boolean;
        followToHead?: boolean;
        rawTx?: ElectrumRawTransaction;
        historyCache?: TxI[];
    }): Promise<AuthChain>;
    /**
     * fetchAuthChainFromChaingraph Fetch the authchain information from a trusted external indexer
     * The authchain in this implementation is specific to resolve to a valid metadata registry
     *
     * @param  {string} options.chaingraphUrl (required) URL of a chaingraph indexer instance to fetch info from
     * @param  {string} options.transactionHash (required) transaction hash from which to build the auth chain
     * @param  {string?} options.network (default=mainnet) network to query the data from, specific to the queried instance, can be mainnet, chipnet, or anything else
     *
     * @returns {AuthChain} returns the resolved authchain
     */
    static fetchAuthChainFromChaingraph(options: {
        chaingraphUrl: string;
        transactionHash: string;
        network?: string;
    }): Promise<AuthChain>;
    /**
     * addMetadataRegistryAuthChain Add BCMR metadata registry by resolving an authchain
     *
     * @param  {string} options.transactionHash (required) transaction hash from which to build the auth chain
     * @param  {Network?} options.network (default=mainnet) network to query the data from
     * @param  {boolean?} options.followToHead (default=true) boolean flag to indicate that autchain building should progress to head (most recent registry version) or be stopped at this exact chain element
     * @param  {ElectrumRawTransaction?} options.rawTx cached raw transaction obtained previously, spares a Fulcrum call
     *
     * @returns {AuthChain} returns the resolved authchain
     */
    static addMetadataRegistryAuthChain(options: {
        transactionHash: string;
        network?: Network;
        followToHead?: boolean;
        rawTx?: ElectrumRawTransaction;
    }): Promise<AuthChain>;
    /**
     * getTokenInfo Return the token info (or the identity snapshot as per spec)
     *
     * @param  {string} tokenId token id to look up
     *
     * @returns {IdentitySnapshot?} return the info for the token found, otherwise undefined
     */
    static getTokenInfo(tokenId: string): IdentitySnapshot | undefined;
}
//# sourceMappingURL=Bcmr.d.ts.map