/// <reference types="node" />
import { BalanceResponse } from "../util/balanceObjectFromSatoshi.js";
import { UnitEnum } from "../enum.js";
import { NFTCapability, UtxoI } from "../interface.js";
import { Input, Output } from "@bitauth/libauth";
export declare type SendRequestType = SendRequest | TokenSendRequest | OpReturnData | Array<SendRequest | TokenSendRequest | OpReturnData> | SendRequestArray[];
export declare class SendRequest {
    cashaddr: string;
    value: number;
    unit: UnitEnum;
    constructor({ cashaddr, value, unit, }: {
        cashaddr: string;
        value: number;
        unit: UnitEnum;
    });
}
export declare class TokenGenesisRequest {
    amount?: number;
    capability?: NFTCapability;
    commitment?: string;
    cashaddr?: string;
    value?: number;
    constructor({ amount, capability, commitment, cashaddr, value, }: {
        amount?: number;
        capability?: NFTCapability;
        commitment?: string;
        cashaddr?: string;
        value?: number;
    });
}
export declare class TokenBurnRequest {
    tokenId: string;
    capability?: NFTCapability;
    commitment?: string;
    amount?: number;
    cashaddr?: string;
    constructor({ tokenId, capability, commitment, amount, cashaddr, }: {
        tokenId: string;
        capability?: NFTCapability;
        commitment?: string;
        amount?: number;
        cashaddr?: string;
    });
}
export declare class TokenSendRequest {
    cashaddr: string;
    value?: number;
    amount: number;
    tokenId: string;
    capability?: NFTCapability;
    commitment?: string;
    constructor({ cashaddr, value, amount, tokenId, capability, commitment, }: {
        cashaddr: string;
        value?: number;
        amount?: number;
        tokenId: string;
        capability?: NFTCapability;
        commitment?: string;
    });
}
export declare class TokenMintRequest {
    capability?: NFTCapability;
    commitment?: string;
    cashaddr?: string;
    value?: number;
    constructor({ capability, commitment, cashaddr, value, }: {
        capability?: NFTCapability;
        commitment?: string;
        cashaddr?: string;
        value?: number;
    });
}
export declare class OpReturnData {
    buffer: Buffer;
    constructor(buffer: Buffer);
    /**
     * from - Construct OP_RETURN data from arbitrary data type
     *
     * @param string   UTF-8 encoded string message to be converted to OP_RETURN data
     *
     * @returns class instance
     */
    static from(data: string | Buffer | Uint8Array): OpReturnData;
    /**
     * fromString - Accept data as a simple UTF-8 string message and append an OP_RETURN and PUSH_DATA1 opcodes to it
     *
     * @param string   UTF-8 encoded string message to be converted to OP_RETURN data
     *
     * @returns class instance
     */
    static fromString(string: string): OpReturnData;
    /**
     * buffer - Accept OP_RETURN data as a binary buffer.
     * If buffer lacks the OP_RETURN and OP_PUSHDATA opcodes, they will be prepended.
     *
     * @param buffer   Data buffer to be assigned to the OP_RETURN outpit
     *
     * @returns class instance
     */
    static fromBuffer(buffer: Buffer): OpReturnData;
    /**
     * buffer - Accept OP_RETURN data as a binary buffer.
     * If buffer lacks the OP_RETURN and OP_PUSHDATA opcodes, they will be prepended.
     *
     * @param buffer   Data buffer to be assigned to the OP_RETURN outpit
     *
     * @returns class instance
     */
    static fromUint8Array(uint8Array: Uint8Array): OpReturnData;
    /**
     * fromArray - Accept array of data
     *
     * @param array   Array of Buffer or UTF-8 encoded string messages to be converted to OP_RETURN data
     *
     * @returns class instance
     */
    static fromArray(array: Array<string | Buffer | Uint8Array>): OpReturnData;
    /**
     * parseBinary - parse OP_RETURN data and return pushed chunks of binary data
     *
     * @param opReturn   Raw OP_RETURN data
     *
     * @returns array of binary data chunks pushed
     */
    static parseBinary(opReturn: Uint8Array): Uint8Array[];
    /**
     * parse - parse OP_RETURN hex data and return pushed chunks of binary data, converted to utf8 strings
     *
     * @param opReturn   Raw OP_RETURN hex data
     *
     * @returns array of binary data chunks pushed, converted to utf8 strings
     */
    static parse(opReturnHex: string): string[];
}
export declare type SendRequestArray = Array<string | number | UnitEnum | Buffer>;
export declare type SourceOutput = Input & Output;
export declare class SendResponse {
    txId?: string;
    balance?: BalanceResponse;
    explorerUrl?: string;
    tokenIds?: string[];
    unsignedTransaction?: string;
    sourceOutputs?: SourceOutput[];
    constructor({ txId, balance, explorerUrl, }: {
        txId?: string;
        balance?: any;
        explorerUrl?: string;
    });
}
export declare class XPubKey {
    path: string;
    xPubKey: string;
    constructor({ path, xPubKey }: {
        path: string;
        xPubKey: string;
    });
    ready(): Promise<{
        path: string;
        xPubKey: string;
    }>;
    asObject(): {
        path: string;
        xPubKey: string;
    };
}
export declare const fromUtxoId: (utxoId: string) => UtxoI;
export declare const toUtxoId: (utxo: UtxoI) => string;
//# sourceMappingURL=model.d.ts.map