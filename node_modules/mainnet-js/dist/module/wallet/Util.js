import { RegTestWallet, RegTestWatchWallet, RegTestWifWallet, TestNetWallet, TestNetWatchWallet, TestNetWifWallet, Wallet, WatchWallet, WifWallet, } from "../wallet/Wif.js";
import { binToHex, decodeTransaction as decodeTransactionLibAuth, hexToBin, lockingBytecodeToCashAddress, } from "@bitauth/libauth";
import { bchParam } from "../chain.js";
import { getTransactionHash } from "../util/transaction.js";
/**
 * Class with various wallet utilities.
 */
export class Util {
    /**
     * Initializes a wallet Util class.
     *
     * @param wallet     A wallet object
     */
    constructor(wallet) {
        this.wallet = wallet;
    }
    static get walletType() {
        return Wallet;
    }
    async getTransactionHash(rawTransactionHex) {
        return getTransactionHash(rawTransactionHex);
    }
    static async getTransactionHash(rawTransactionHex) {
        return getTransactionHash(rawTransactionHex);
    }
    async decodeTransaction(transactionHashOrHex, loadInputValues = false) {
        let transactionHex;
        let transactionBin;
        let txHash;
        // raw transaction
        if (transactionHashOrHex.length > 64) {
            txHash = await this.getTransactionHash(transactionHashOrHex);
            transactionBin = hexToBin(transactionHashOrHex);
            transactionHex = transactionHashOrHex;
        }
        else {
            // tx hash, look up the raw transaction
            txHash = transactionHashOrHex;
            transactionHex = await this.wallet.provider.getRawTransaction(txHash);
            transactionBin = hexToBin(transactionHex);
        }
        const result = decodeTransactionLibAuth(transactionBin);
        if (typeof result === "string") {
            throw Error(result);
        }
        const transaction = this.mapToElectrumRawTransaction(result, txHash, transactionHex);
        if (loadInputValues) {
            // get unique transaction hashes
            const hashes = [...new Set(transaction.vin.map((val) => val.txid))];
            const transactions = await Promise.all(hashes.map((hash) => this.decodeTransaction(hash, false)));
            const transactionMap = new Map();
            transactions.forEach((val) => transactionMap.set(val.hash, val));
            transaction.vin.forEach((input) => {
                const output = transactionMap
                    .get(input.txid)
                    .vout.find((val) => val.n === input.vout);
                input.address = output.scriptPubKey.addresses[0];
                input.value = output.value;
                input.tokenData = output.tokenData;
            });
        }
        return transaction;
    }
    mapToElectrumRawTransaction(transaction, txHash, txHex) {
        let result = {};
        result.vin = transaction.inputs.map((input) => {
            return {
                scriptSig: {
                    hex: binToHex(input.unlockingBytecode),
                },
                sequence: input.sequenceNumber,
                txid: binToHex(input.outpointTransactionHash),
                vout: input.outpointIndex,
            };
        });
        result.vout = transaction.outputs.map((output, index) => {
            return {
                n: index,
                scriptPubKey: {
                    addresses: [
                        lockingBytecodeToCashAddress(output.lockingBytecode, this.wallet.networkPrefix).toString(),
                    ],
                    hex: binToHex(output.lockingBytecode),
                },
                value: Number(output.valueSatoshis) / bchParam.subUnits,
            };
        });
        result.locktime = transaction.locktime;
        result.version = transaction.version;
        result.hash = txHash;
        result.hex = txHex;
        result.txid = txHash;
        result.size = txHex.length / 2;
        return result;
    }
    static async decodeTransaction(transactionHashOrHex, loadInputValues = false) {
        return new this.walletType().util.decodeTransaction(transactionHashOrHex, loadInputValues);
    }
}
//#region Specific wallet classes
/**
 * Class to manage an slp enabled testnet wallet.
 */
export class TestNetUtil extends Util {
    static get walletType() {
        return TestNetWallet;
    }
}
/**
 * Class to manage an slp enabled regtest wallet.
 */
export class RegTestUtil extends Util {
    static get walletType() {
        return RegTestWallet;
    }
}
/**
 * Class to manage a bitcoin cash wif wallet.
 */
export class WifUtil extends Util {
    static get walletType() {
        return WifWallet;
    }
}
/**
 * Class to manage a testnet wif wallet.
 */
export class TestNetWifUtil extends Util {
    static get walletType() {
        return TestNetWifWallet;
    }
}
/**
 * Class to manage a regtest wif wallet.
 */
export class RegTestWifUtil extends Util {
    static get walletType() {
        return RegTestWifWallet;
    }
}
/**
 * Class to manage a bitcoin cash watch wallet.
 */
export class WatchUtil extends Util {
    static get walletType() {
        return WatchWallet;
    }
}
/**
 * Class to manage a testnet watch wallet.
 */
export class TestNetWatchUtil extends Util {
    static get walletType() {
        return TestNetWatchWallet;
    }
}
/**
 * Class to manage a regtest watch wallet.
 */
export class RegTestWatchUtil extends Util {
    static get walletType() {
        return RegTestWatchWallet;
    }
}
//#endregion
//# sourceMappingURL=Util.js.map