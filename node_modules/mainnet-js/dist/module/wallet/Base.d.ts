import { MnemonicI, WalletI } from "./interface.js";
import { NetworkType } from "../enum.js";
import { StorageProvider } from "../db/index.js";
import { ImageI } from "../qr/interface.js";
import { WalletTypeEnum } from "./enum.js";
/**
 * A class to hold features used by all wallets
 * @class  BaseWallet
 */
export declare class BaseWallet implements WalletI {
    provider?: any;
    derivationPath: string;
    parentDerivationPath: string;
    parentXPubKey?: string;
    mnemonic?: string;
    address?: string;
    privateKey?: any;
    publicKey?: any;
    storage?: StorageProvider;
    isTestnet: boolean;
    name: string;
    network: NetworkType;
    walletType: WalletTypeEnum;
    protected getNetworkProvider(network?: NetworkType): any;
    /**
     * getDepositAddress - get a wallet deposit address
     *
     * a high-level function,
     *
     * @see {@link https://rest-unstable.mainnet.cash/api-docs/#/wallet/depositAddress|/wallet/deposit_address} for REST endpoint
     *
     * @returns The deposit address as a string
     */
    getDepositAddress(): string;
    /**
     * getDepositQr - get an address qrcode, encoded for display on the web
     *
     * a high-level function
     *
     * @see {@link https://rest-unstable.mainnet.cash/api-docs/#/wallet/depositQr|/wallet/deposit_qr} for REST endpoint
     *
     * @returns The qrcode for the address
     */
    getDepositQr(): ImageI;
    getSeed(): MnemonicI;
    /**
     * constructor for a new wallet
     * @param {string} name              name of the wallet
     * @param network              network for wallet
     *
     * @throws {Error} if called on BaseWallet
     */
    constructor(name?: string, network?: NetworkType, walletType?: WalletTypeEnum);
    /**
     * fromId - create a wallet from encoded walletId string
     *
     * @param walletId   walletId options to steer the creation process
     *
     * @returns wallet instantiated accordingly to the walletId rules
     */
    static fromId<T extends typeof BaseWallet>(this: T, walletId: string): Promise<InstanceType<T>>;
    /**
     * fromSeed - create a wallet using the seed phrase and derivation path
     *
     * unless specified the derivation path m/44'/245'/0'/0/0 will be userd
     * this derivation path is standard for Electron Cash SLP and other SLP enabled wallets
     *
     * @param seed   BIP39 12 word seed phrase
     * @param derivationPath BIP44 HD wallet derivation path to get a single the private key from hierarchy
     *
     * @returns instantiated wallet
     */
    static fromSeed<T extends typeof BaseWallet>(this: T, seed: string, derivationPath?: string): Promise<InstanceType<T>>;
    /**
     * newRandom - create a random wallet
     *
     * if `name` parameter is specified, the wallet will also be persisted to DB
     *
     * @param name   user friendly wallet alias
     * @param dbName name under which the wallet will be stored in the database
     *
     * @returns instantiated wallet
     */
    static newRandom<T extends typeof BaseWallet>(this: T, name?: string, dbName?: string): Promise<InstanceType<T>>;
    /**
     * watchOnly - create a watch-only wallet
     *
     * such kind of wallet does not have a private key and is unable to spend any funds
     * however it still allows to use many utility functions such as getting and watching balance, etc.
     *
     * @param address   cashaddress, token aware cashaddress or slpaddress of a wallet
     *
     * @returns instantiated wallet
     */
    static watchOnly<T extends typeof BaseWallet>(this: T, address: string): Promise<InstanceType<T>>;
    /**
     * named - create a named wallet
     *
     * @param name   user friendly wallet alias
     * @param dbName name under which the wallet will be stored in the database
     * @param force  force recreate wallet in the database if a record already exist
     *
     * @returns instantiated wallet
     */
    static named<T extends typeof BaseWallet>(this: T, name: string, dbName?: string, force?: boolean): Promise<InstanceType<T>>;
    /**
     * replaceNamed - replace (recover) named wallet with a new walletId
     *
     * If wallet with a provided name does not exist yet, it will be created with a `walletId` supplied
     * If wallet exists it will be overwritten without exception
     *
     * @param name   user friendly wallet alias
     * @param walletId walletId options to steer the creation process
     * @param dbName name under which the wallet will be stored in the database
     *
     * @returns instantiated wallet
     */
    static replaceNamed<T extends typeof BaseWallet>(this: T, name: string, walletId: string, dbName?: string): Promise<InstanceType<T>>;
    /**
     * namedExists - check if a named wallet already exists
     *
     * @param name   user friendly wallet alias
     * @param dbName name under which the wallet will be stored in the database
     *
     * @returns boolean
     */
    static namedExists(name: string, dbName?: string): Promise<boolean>;
    /**
     * generate creates a new wallet
     * @throws {Error} if called on BaseWallet
     */
    protected generate(): Promise<this>;
    /**
     * fromId - creates a wallet from serialized string
     *
     * @throws {Error} if called on BaseWallet
     */
    protected fromId(walletId: string): Promise<this>;
    protected fromSeed(mnemonic: string, derivationPath?: string): Promise<this>;
    /**
     * newRandom (internal) if the wallet is named, get or create it; otherwise create a random
     * unnamed wallet
     * @param {string} name              name of the wallet
     * @param {string} dbName            database name the wallet is stored in
     */
    protected newRandom(name: string, dbName?: string): Promise<this>;
    protected watchOnly(address: string): Promise<this>;
    /**
     * named (internal) get a named wallet from the database or create a new one.
     * Note: this function should behave identically if
     *
     * @param {string} name              name of the wallet
     * @param {string} dbName            database name the wallet is stored in
     * @param {boolean} forceNew         attempt to overwrite an existing wallet
     *
     * @throws {Error} if forceNew is true and the wallet already exists
     * @returns a promise to a named wallet
     */
    protected named(name: string, dbName?: string, forceNew?: boolean): Promise<this>;
    /**
     * replaceNamed - Replace (recover) named wallet with a new walletId
     *
     * If wallet with a provided name does not exist yet, it will be created with a `walletId` supplied
     * If wallet exists it will be overwritten without exception
     *
     * @param name   user friendly wallet alias
     * @param walletId walletId options to steer the creation process
     * @param dbName name under which the wallet will be stored in the database
     *
     * @returns instantiated wallet
     */
    protected replaceNamed(name: string, walletId: string, dbName?: string): Promise<this>;
    /**
     * namedExists - check if a named wallet already exists
     *
     * @param name   user friendly wallet alias
     * @param dbName name under which the wallet will be stored in the database
     *
     * @returns boolean
     */
    protected namedExists(name: string, dbName?: string): Promise<boolean>;
    /**
     * toDbString - store the serialized version of the wallet in the database, not just the name
     *
     * @throws {Error} if called on BaseWallet
     */
    toDbString(): string;
    toString(): string;
    getBalance(rawUnit?: any): Promise<any>;
    getMaxAmountToSend(params?: any): Promise<any>;
    send(requests: any, options?: any): Promise<any>;
    sendMax(address: string, options?: any): Promise<any>;
}
/**
 * getNamedWalletId - get the full wallet id from the database
 *
 * @param name   user friendly wallet alias
 * @param dbName name under which the wallet will be stored in the database
 *
 * @returns boolean
 */
export declare function getNamedWalletId(name: string, dbName?: string): Promise<string | undefined>;
//# sourceMappingURL=Base.d.ts.map