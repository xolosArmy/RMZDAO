import { CashAddressNetworkPrefix } from "@bitauth/libauth";
import { NetworkType, UnitEnum } from "../enum.js";
import { Network, HeaderI, TxI } from "../interface.js";
import { UtxoI } from "../interface.js";
import { BaseWallet } from "./Base.js";
import { WalletTypeEnum } from "./enum.js";
import { CancelWatchFn, SendRequestOptionsI, WaitForTransactionOptions, WaitForTransactionResponse, WalletInfoI } from "./interface.js";
import { OpReturnData, SendRequest, SendRequestArray, SendRequestType, SendResponse, SourceOutput, TokenBurnRequest, TokenGenesisRequest, TokenMintRequest, TokenSendRequest } from "./model.js";
import { BalanceResponse } from "../util/balanceObjectFromSatoshi.js";
import { ElectrumRawTransaction } from "../network/interface.js";
import { RegTestSlp, RegTestWatchSlp, RegTestWifSlp, Slp, TestNetSlp, TestNetWatchSlp, TestNetWifSlp, WatchSlp, WifSlp } from "./Slp.js";
import { SlpSendResponse } from "../slp/interface.js";
import { RegTestUtil, RegTestWatchUtil, RegTestWifUtil, TestNetUtil, TestNetWatchUtil, TestNetWifUtil, Util, WatchUtil, WifUtil } from "./Util.js";
import { SignedMessageI } from "../message/index.js";
import { TransactionHistoryI } from "../history/interface.js";
import { IdentitySnapshot } from "./bcmr-v2.schema.js";
import { ImageI } from "../qr/interface.js";
/**
 * Class to manage a bitcoin cash wallet.
 */
export declare class Wallet extends BaseWallet {
    static networkPrefix: CashAddressNetworkPrefix;
    cashaddr?: string;
    tokenaddr?: string;
    derivationPath: string;
    parentDerivationPath: string;
    parentXPubKey?: string;
    privateKey?: Uint8Array;
    publicKeyCompressed?: Uint8Array;
    privateKeyWif?: string;
    publicKey?: Uint8Array;
    publicKeyHash?: Uint8Array;
    networkPrefix: CashAddressNetworkPrefix;
    _slp?: Slp;
    _slpAware: boolean;
    _slpSemiAware: boolean;
    _util?: Util;
    static signedMessage: SignedMessageI;
    get slp(): Slp;
    static get slp(): typeof Slp;
    get util(): Util;
    static get util(): typeof Util;
    slpAware(value?: boolean): Wallet;
    slpSemiAware(value?: boolean): Wallet;
    getNetworkProvider(network?: Network): import("../network/NetworkProvider.js").default;
    /**
     * getTokenDepositAddress - get a cashtoken aware wallet deposit address
     *
     * @returns The cashtoken aware deposit address as a string
     */
    getTokenDepositAddress(): string;
    /**
     * getDepositQr - get an address qrcode, encoded for display on the web
     *
     * @returns The qrcode for the token aware address
     */
    getTokenDepositQr(): ImageI;
    /**
     *  explorerUrl   Web url to a transaction on a block explorer
     *
     * @param txId   transaction Id
     * @returns   Url string
     */
    explorerUrl(txId: string): string;
    getInfo(): WalletInfoI;
    getPublicKey(hex?: boolean): string | Uint8Array;
    getPublicKeyCompressed(hex?: boolean): string | Uint8Array;
    getPublicKeyHash(hex?: boolean): string | Uint8Array;
    constructor(name?: string, network?: NetworkType, walletType?: WalletTypeEnum);
    /**
     * fromWIF - create a wallet using the private key supplied in `Wallet Import Format`
     *
     * @param wif   WIF encoded private key string
     *
     * @returns instantiated wallet
     */
    static fromWIF<T extends typeof Wallet>(this: T, wif: string): Promise<InstanceType<T>>;
    /**
     * fromCashaddr - create a watch-only wallet in the network derived from the address
     *
     * such kind of wallet does not have a private key and is unable to spend any funds
     * however it still allows to use many utility functions such as getting and watching balance, etc.
     *
     * @param address   cashaddress of a wallet
     *
     * @returns instantiated wallet
     */
    static fromCashaddr<T extends typeof Wallet>(this: T, address: string): Promise<InstanceType<T>>;
    /**
     * fromTokenaddr - create a watch-only wallet in the network derived from the address
     *
     * such kind of wallet does not have a private key and is unable to spend any funds
     * however it still allows to use many utility functions such as getting and watching balance, etc.
     *
     * @param address   token aware cashaddress of a wallet
     *
     * @returns instantiated wallet
     */
    static fromTokenaddr<T extends typeof Wallet>(this: T, address: string): Promise<InstanceType<T>>;
    /**
     * fromSlpaddr - create an SLP aware watch-only wallet in the network derived from the address
     *
     * such kind of wallet does not have a private key and is unable to spend any funds
     * however it still allows to use many utility functions such as getting and watching balance, etc.
     *
     * @param address   slpaddress of a wallet
     *
     * @returns instantiated wallet
     */
    static fromSlpaddr<T extends typeof Wallet>(this: T, address: string): Promise<InstanceType<T>>;
    protected generate(): Promise<this>;
    private _generateWif;
    private _generateMnemonic;
    protected fromId: (walletId: string) => Promise<this>;
    getXPubKeys(paths?: any): Promise<any[]>;
    protected fromSeed(mnemonic: string, derivationPath?: string): Promise<this>;
    deriveHdPaths(hdPaths: string[]): Promise<any[]>;
    protected watchOnly(address: string): Promise<this>;
    protected fromWIF(secret: string): Promise<this>;
    protected newRandom(name: string, dbName?: string): Promise<this>;
    protected named(name: string, dbName?: string, forceNew?: boolean): Promise<this>;
    protected replaceNamed(name: string, walletId: string, dbName?: string): Promise<this>;
    protected namedExists(name: string, dbName?: string): Promise<boolean>;
    toString(): string;
    toDbString(): string;
    getAddressUtxos(address?: string): Promise<UtxoI[]>;
    /**
     * utxos Get unspent outputs for the wallet
     *
     */
    getUtxos(): Promise<UtxoI[]>;
    getBalance(rawUnit?: string, usdPriceCache?: boolean): Promise<BalanceResponse | number>;
    getBalanceFromUtxos(): Promise<number>;
    getBalanceFromProvider(): Promise<number>;
    watchAddress(callback: (txHash: string) => void): CancelWatchFn;
    watchAddressTransactions(callback: (tx: ElectrumRawTransaction) => void): CancelWatchFn;
    watchAddressTokenTransactions(callback: (tx: ElectrumRawTransaction) => void): CancelWatchFn;
    watchBalance(callback: (balance: BalanceResponse) => void): CancelWatchFn;
    watchBalanceUsd(callback: (balance: BalanceResponse) => void, usdPriceRefreshInterval?: number): CancelWatchFn;
    waitForBalance(value: number, rawUnit?: UnitEnum): Promise<BalanceResponse>;
    watchTokenBalance(tokenId: string, callback: (balance: number) => void): CancelWatchFn;
    waitForTokenBalance(tokenId: string, amount: number): Promise<number>;
    getTokenInfo(tokenId: string): Promise<IdentitySnapshot | undefined>;
    private _getMaxAmountToSend;
    getMaxAmountToSend(params?: {
        outputCount?: number;
        options?: SendRequestOptionsI;
    }): Promise<BalanceResponse>;
    /**
     * send Send some amount to an address
     * this function processes the send requests, encodes the transaction, sends it to the network
     * @returns (depending on the options parameter) the transaction id, new address balance and a link to the transaction on the blockchain explorer
     *
     * This is a first class function with REST analog, maintainers should strive to keep backward-compatibility
     *
     */
    send(requests: SendRequest | TokenSendRequest | OpReturnData | Array<SendRequest | TokenSendRequest | OpReturnData> | SendRequestArray[], options?: SendRequestOptionsI): Promise<SendResponse>;
    /**
     * sendMax Send all available funds to a destination cash address
     *
     * @param  {string} cashaddr destination cash address
     * @param  {SendRequestOptionsI} options Options of the send requests
     *
     * @returns (depending on the options parameter) the transaction id, new address balance and a link to the transaction on the blockchain explorer
     */
    sendMax(cashaddr: string, options?: SendRequestOptionsI): Promise<SendResponse>;
    /**
     * sendMaxRaw (internal) Send all available funds to a destination cash address
     *
     * @param  {string} cashaddr destination cash address
     * @param  {SendRequestOptionsI} options Options of the send requests
     *
     * @returns the transaction id sent to the network
     */
    private sendMaxRaw;
    /**
     * encodeTransaction Encode and sign a transaction given a list of sendRequests, options and estimate fees.
     * @param  {SendRequest[]} sendRequests SendRequests
     * @param  {boolean} discardChange=false
     * @param  {SendRequestOptionsI} options Options of the send requests
     */
    encodeTransaction(requests: SendRequest | TokenSendRequest | OpReturnData | Array<SendRequest | TokenSendRequest | OpReturnData> | SendRequestArray[], discardChange?: boolean, options?: SendRequestOptionsI): Promise<{
        encodedTransaction: Uint8Array;
        tokenIds: string[];
        sourceOutputs: any[];
    }>;
    signUnsignedTransaction(transaction: Uint8Array | string, sourceOutputs: SourceOutput[]): Promise<Uint8Array>;
    submitTransaction(transaction: Uint8Array, awaitPropagation?: boolean): Promise<string>;
    getRawHistory(): Promise<TxI[]>;
    getHistory(unit: UnitEnum, start?: number, count?: number, collapseChange?: boolean): Promise<TransactionHistoryI>;
    getLastTransaction(confirmedOnly?: boolean): Promise<ElectrumRawTransaction | null>;
    waitForTransaction(options?: WaitForTransactionOptions): Promise<WaitForTransactionResponse>;
    /**
     * watchBlocks Watch network blocks
     *
     * @param callback callback with a block header object
     *
     * @returns a function which will cancel watching upon evaluation
     */
    watchBlocks(callback: (header: HeaderI) => void): CancelWatchFn;
    /**
     * waitForBlock Wait for a network block
     *
     * @param height if specified waits for this exact blockchain height, otherwise resolves with the next block
     *
     */
    waitForBlock(height?: number): Promise<HeaderI>;
    private deriveInfo;
    sign(message: string): Promise<import("../message/interface.js").SignedMessageResponseI>;
    verify(message: string, sig: string, publicKey?: Uint8Array): Promise<import("../message/interface.js").VerifyMessageResponseI>;
    /**
     * Create new cashtoken, both funglible and/or non-fungible (NFT)
     * Refer to spec https://github.com/bitjson/cashtokens
     * @param  {number} genesisRequest.amount amount of *fungible* tokens to create
     * @param  {NFTCapability?} genesisRequest.capability capability of new NFT
     * @param  {string?} genesisRequest.commitment NFT commitment message
     * @param  {string?} genesisRequest.cashaddr cash address to send the created token UTXO to; if undefined will default to your address
     * @param  {number?} genesisRequest.value satoshi value to send alongside with tokens; if undefined will default to 1000 satoshi
     * @param  {SendRequestType | SendRequestType[]} sendRequests single or an array of extra send requests (OP_RETURN, value transfer, etc.) to include in genesis transaction
     * @param  {SendRequestOptionsI} options Options of the send requests
     */
    tokenGenesis(genesisRequest: TokenGenesisRequest, sendRequests?: SendRequestType | SendRequestType[], options?: SendRequestOptionsI): Promise<SendResponse>;
    /**
     * Mint new NFT cashtokens using an existing minting token
     * Refer to spec https://github.com/bitjson/cashtokens
     * @param  {string} tokenId tokenId of an NFT to mint
     * @param  {TokenMintRequest | TokenMintRequest[]} mintRequests mint requests with new token properties and recipients
     * @param  {NFTCapability?} mintRequest.capability capability of new NFT
     * @param  {string?} mintRequest.commitment NFT commitment message
     * @param  {string?} mintRequest.cashaddr cash address to send the created token UTXO to; if undefined will default to your address
     * @param  {number?} mintRequest.value satoshi value to send alongside with tokens; if undefined will default to 1000 satoshi
     * @param  {boolean?} deductTokenAmount if minting token contains fungible amount, deduct from it by amount of minted tokens
     * @param  {SendRequestOptionsI} options Options of the send requests
     */
    tokenMint(tokenId: string, mintRequests: TokenMintRequest | Array<TokenMintRequest>, deductTokenAmount?: boolean, options?: SendRequestOptionsI): Promise<SendResponse>;
    /**
     * Perform an explicit token burning by spending a token utxo to an OP_RETURN
     *
     * Behaves differently for fungible and non-fungible tokens:
     *  * NFTs are always "destroyed"
     *  * FTs' amount is reduced by the amount specified, if 0 FT amount is left and no NFT present, the token is "destroyed"
     *
     * Refer to spec https://github.com/bitjson/cashtokens
     * @param  {string} burnRequest.tokenId tokenId of a token to burn
     * @param  {NFTCapability} burnRequest.capability capability of the NFT token to select, optional
     * @param  {string?} burnRequest.commitment commitment of the NFT token to select, optional
     * @param  {number?} burnRequest.amount amount of fungible tokens to burn, optional
     * @param  {string?} burnRequest.cashaddr address to return token and satoshi change to
     * @param  {string?} message optional message to include in OP_RETURN
     * @param  {SendRequestOptionsI} options Options of the send requests
     */
    tokenBurn(burnRequest: TokenBurnRequest, message?: string, options?: SendRequestOptionsI): Promise<SendResponse>;
    /**
     * getTokenUtxos Get unspent token outputs for the wallet
     * will return utxos only for the specified token if `tokenId` provided
     * @param  {string?} tokenId tokenId (category) to filter utxos by, if not set will return utxos from all tokens
     * @returns  {UtxoI[]} token utxos
     */
    getTokenUtxos(tokenId?: string): Promise<UtxoI[]>;
    /**
     * getTokenBalance Gets fungible token balance
     * for NFT token balance see @ref getNftTokenBalance
     * @param  {string} tokenId tokenId to get balance for
     * @returns  {number} fungible token balance
     */
    getTokenBalance(tokenId: string): Promise<number>;
    /**
     * getNftTokenBalance Gets non-fungible token (NFT) balance for a particula tokenId
     * disregards fungible token balances
     * for fungible token balance see @ref getTokenBalance
     * @param  {string} tokenId tokenId to get balance for
     * @returns  {number} non-fungible token balance
     */
    getNftTokenBalance(tokenId: string): Promise<number>;
    /**
     * getAllTokenBalances Gets all fungible token balances in this wallet
     * @returns  {Object} a map [tokenId => balance] for all tokens in this wallet
     */
    getAllTokenBalances(): Promise<{
        [tokenId: string]: number;
    }>;
    /**
     * getAllNftTokenBalances Gets all non-fungible token (NFT) balances in this wallet
     * @returns  {Object} a map [tokenId => balance] for all NFTs in this wallet
     */
    getAllNftTokenBalances(): Promise<{
        [tokenId: string]: number;
    }>;
}
/**
 * Class to manage a testnet wallet.
 */
export declare class TestNetWallet extends Wallet {
    static networkPrefix: CashAddressNetworkPrefix;
    static faucetServer: string;
    constructor(name?: string);
    getTestnetSatoshis(): Promise<string>;
    returnTestnetSatoshis(): Promise<SendResponse>;
    getTestnetSlp(tokenId: string): Promise<string>;
    returnTestnetSlp(tokenId: string): Promise<SlpSendResponse>;
    static get slp(): typeof TestNetSlp;
    static get util(): typeof TestNetUtil;
}
/**
 * Class to manage a regtest wallet.
 */
export declare class RegTestWallet extends Wallet {
    static networkPrefix: CashAddressNetworkPrefix;
    constructor(name?: string);
    static get slp(): typeof RegTestSlp;
    static get util(): typeof RegTestUtil;
}
/**
 * Class to manage a bitcoin cash wif wallet.
 */
export declare class WifWallet extends Wallet {
    static networkPrefix: CashAddressNetworkPrefix;
    static walletType: WalletTypeEnum;
    constructor(name?: string);
    static get slp(): typeof WifSlp;
    static get util(): typeof WifUtil;
}
/**
 * Class to manage a testnet wif wallet.
 */
export declare class TestNetWifWallet extends Wallet {
    static networkPrefix: CashAddressNetworkPrefix;
    static walletType: WalletTypeEnum;
    constructor(name?: string);
    static get slp(): typeof TestNetWifSlp;
    static get util(): typeof TestNetWifUtil;
}
/**
 * Class to manage a regtest wif wallet.
 */
export declare class RegTestWifWallet extends Wallet {
    static networkPrefix: CashAddressNetworkPrefix;
    static walletType: WalletTypeEnum;
    constructor(name?: string);
    static get slp(): typeof RegTestWifSlp;
    static get util(): typeof RegTestWifUtil;
}
/**
 * Class to manage a bitcoin cash watch wallet.
 */
export declare class WatchWallet extends Wallet {
    static networkPrefix: CashAddressNetworkPrefix;
    static walletType: WalletTypeEnum;
    constructor(name?: string);
    static get slp(): typeof WatchSlp;
    static get util(): typeof WatchUtil;
}
/**
 * Class to manage a testnet watch wallet.
 */
export declare class TestNetWatchWallet extends Wallet {
    static networkPrefix: CashAddressNetworkPrefix;
    static walletType: WalletTypeEnum;
    constructor(name?: string);
    static get slp(): typeof TestNetWatchSlp;
    static get util(): typeof TestNetWatchUtil;
}
/**
 * Class to manage a regtest watch wallet.
 */
export declare class RegTestWatchWallet extends Wallet {
    static networkPrefix: CashAddressNetworkPrefix;
    static walletType: WalletTypeEnum;
    constructor(name?: string);
    static get slp(): typeof RegTestWatchSlp;
    static get util(): typeof RegTestWatchUtil;
}
//# sourceMappingURL=Wif.d.ts.map