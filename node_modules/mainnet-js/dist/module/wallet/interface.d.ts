import { WalletTypeEnum, FeePaidByEnum } from "./enum.js";
import { NetworkEnum } from "../enum.js";
import { ImageI } from "../qr/interface.js";
import { ElectrumRawTransaction } from "../network/interface.js";
import { BalanceResponse } from "../util/balanceObjectFromSatoshi.js";
import { UtxoI } from "../interface.js";
export interface WalletRequestI {
    name?: string;
    network?: string;
    type?: WalletTypeEnum;
    platform?: string;
    walletId?: string;
}
export interface WalletResponseI {
    name: string;
    cashaddr?: string;
    slpaddr?: string;
    address?: string;
    walletId: string;
    network?: NetworkEnum;
    wif?: string;
    privkey?: string;
    seed?: string;
    derivationPath?: string;
    parentDerivationPath?: string;
}
export interface WalletInfoI {
    cashaddr?: string;
    tokenaddr?: string;
    isTestnet?: boolean;
    name?: string;
    network: NetworkEnum;
    seed?: string;
    derivationPath?: string;
    parentDerivationPath?: string;
    parentXPubKey?: string;
    publicKey?: string;
    publicKeyHash?: string;
    privateKey?: string;
    privateKeyWif?: string;
    walletId: string;
    walletDbEntry: string;
}
export interface SendRequestOptionsI {
    utxoIds?: string[] | UtxoI[];
    changeAddress?: string;
    slpAware?: boolean;
    slpSemiAware?: boolean;
    queryBalance?: boolean;
    awaitTransactionPropagation?: boolean;
    feePaidBy?: FeePaidByEnum;
    checkTokenQuantities?: boolean;
    tokenOperation?: "send" | "genesis" | "mint" | "burn";
    ensureUtxos?: UtxoI[];
    buildUnsigned?: boolean;
}
export interface MnemonicI {
    seed: string;
    derivationPath: string;
    parentDerivationPath: string;
}
export interface WalletI {
    getDepositAddress(): string;
    getDepositQr(): ImageI;
    getSeed(): MnemonicI;
    toString(): string;
    toDbString(): string;
    getBalance(rawUnit?: any): Promise<any>;
    getMaxAmountToSend(params?: any): Promise<any>;
    send(requests: any, options?: any): Promise<any>;
    sendMax(address: string, options?: any): Promise<any>;
}
export interface WaitForTransactionOptions {
    getTransactionInfo?: boolean;
    getBalance?: boolean;
    txHash?: string;
}
export interface WaitForTransactionResponse {
    transactionInfo?: ElectrumRawTransaction;
    balance?: BalanceResponse;
}
export declare type CancelWatchFn = () => Promise<void>;
//# sourceMappingURL=interface.d.ts.map