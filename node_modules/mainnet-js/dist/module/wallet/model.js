import { BalanceResponse } from "../util/balanceObjectFromSatoshi.js";
import { sanitizeUnit } from "../util/sanitizeUnit.js";
import { DELIMITER } from "../constant.js";
import { binToNumberUint16LE, binToUtf8, hexToBin, utf8ToBin, } from "@bitauth/libauth";
import { Config } from "../config.js";
import { checkTokenaddr } from "../util/deriveCashaddr.js";
export class SendRequest {
    constructor({ cashaddr, value, unit, }) {
        this.cashaddr = cashaddr;
        this.value = value;
        this.unit = sanitizeUnit(unit);
    }
}
export class TokenGenesisRequest {
    constructor({ amount, capability, commitment, cashaddr, value, }) {
        this.amount = amount;
        this.capability = capability;
        this.commitment = commitment;
        this.cashaddr = cashaddr;
        this.value = value;
    }
}
export class TokenBurnRequest {
    constructor({ tokenId, capability, commitment, amount, cashaddr, }) {
        this.tokenId = tokenId;
        this.capability = capability;
        this.commitment = commitment;
        this.amount = amount;
        this.cashaddr = cashaddr;
    }
}
export class TokenSendRequest {
    constructor({ cashaddr, value, amount, tokenId, capability, commitment, }) {
        checkTokenaddr(cashaddr, Config.EnforceCashTokenReceiptAddresses);
        this.cashaddr = cashaddr;
        this.value = value;
        this.amount = amount || 0;
        this.tokenId = tokenId;
        this.capability = capability;
        this.commitment = commitment;
    }
}
export class TokenMintRequest {
    constructor({ capability, commitment, cashaddr, value, }) {
        this.capability = capability;
        this.commitment = commitment;
        this.cashaddr = cashaddr;
        this.value = value;
    }
}
export class OpReturnData {
    constructor(buffer) {
        this.buffer = Buffer.from(buffer);
    }
    /**
     * from - Construct OP_RETURN data from arbitrary data type
     *
     * @param string   UTF-8 encoded string message to be converted to OP_RETURN data
     *
     * @returns class instance
     */
    static from(data) {
        return this.fromArray([data]);
    }
    /**
     * fromString - Accept data as a simple UTF-8 string message and append an OP_RETURN and PUSH_DATA1 opcodes to it
     *
     * @param string   UTF-8 encoded string message to be converted to OP_RETURN data
     *
     * @returns class instance
     */
    static fromString(string) {
        return this.fromArray([string]);
    }
    /**
     * buffer - Accept OP_RETURN data as a binary buffer.
     * If buffer lacks the OP_RETURN and OP_PUSHDATA opcodes, they will be prepended.
     *
     * @param buffer   Data buffer to be assigned to the OP_RETURN outpit
     *
     * @returns class instance
     */
    static fromBuffer(buffer) {
        if (buffer[0] !== 0x6a) {
            return this.fromArray([buffer]);
        }
        return new this(buffer);
    }
    /**
     * buffer - Accept OP_RETURN data as a binary buffer.
     * If buffer lacks the OP_RETURN and OP_PUSHDATA opcodes, they will be prepended.
     *
     * @param buffer   Data buffer to be assigned to the OP_RETURN outpit
     *
     * @returns class instance
     */
    static fromUint8Array(uint8Array) {
        if (uint8Array[0] !== 0x6a) {
            return this.fromArray([uint8Array]);
        }
        return new this(Buffer.from(uint8Array));
    }
    /**
     * fromArray - Accept array of data
     *
     * @param array   Array of Buffer or UTF-8 encoded string messages to be converted to OP_RETURN data
     *
     * @returns class instance
     */
    static fromArray(array) {
        let data = Buffer.from([0x6a]); // OP_RETURN
        for (const element of array) {
            let length;
            let elementData;
            let lengthData;
            if (typeof element === "string") {
                elementData = utf8ToBin(element);
                length = elementData.length;
            }
            else if (element instanceof Buffer) {
                elementData = element;
                length = elementData.length;
            }
            else if (element instanceof Uint8Array) {
                elementData = Buffer.from(element);
                length = elementData.length;
            }
            else {
                throw new Error("Wrong data array element");
            }
            if (length < 76) {
                // OP_PUSHDATA_1
                lengthData = [length];
            }
            else if (length < 223) {
                // default max `-datacarriersize`
                lengthData = [0x4c, length];
            }
            else {
                throw new Error("OP_RETURN data can not exceed 220 bytes in size");
            }
            data = Buffer.from([...data, ...lengthData, ...elementData]);
        }
        if (data.length > 220) {
            throw new Error("OP_RETURN data can not exceed 220 bytes in size");
        }
        return new this(data);
    }
    /**
     * parseBinary - parse OP_RETURN data and return pushed chunks of binary data
     *
     * @param opReturn   Raw OP_RETURN data
     *
     * @returns array of binary data chunks pushed
     */
    static parseBinary(opReturn) {
        const chunks = [];
        let position = 1;
        // handle direct push, OP_PUSHDATA1, OP_PUSHDATA2;
        // OP_PUSHDATA4 is not supported in OP_RETURNs by consensus
        while (opReturn[position]) {
            let length = 0;
            if (opReturn[position] === 0x4c) {
                length = opReturn[position + 1];
                position += 2;
            }
            else if (opReturn[position] === 0x4d) {
                length = binToNumberUint16LE(opReturn.slice(position + 1, position + 3));
                position += 3;
            }
            else {
                length = opReturn[position];
                position += 1;
            }
            chunks.push(opReturn.slice(position, position + length));
            position += length;
        }
        return chunks;
    }
    /**
     * parse - parse OP_RETURN hex data and return pushed chunks of binary data, converted to utf8 strings
     *
     * @param opReturn   Raw OP_RETURN hex data
     *
     * @returns array of binary data chunks pushed, converted to utf8 strings
     */
    static parse(opReturnHex) {
        return this.parseBinary(hexToBin(opReturnHex)).map((val) => binToUtf8(val));
    }
}
export class SendResponse {
    constructor({ txId, balance, explorerUrl, }) {
        this.txId = txId;
        this.balance = new BalanceResponse(balance);
        this.explorerUrl = explorerUrl;
    }
}
export class XPubKey {
    constructor({ path, xPubKey }) {
        this.path = path;
        this.xPubKey = xPubKey;
    }
    async ready() {
        await this.xPubKey;
        return this.asObject();
    }
    asObject() {
        return {
            path: this.path,
            xPubKey: this.xPubKey,
        };
    }
}
export const fromUtxoId = (utxoId) => {
    const [txid, vout, satoshis, tokenId, amount, capability, commitment] = utxoId.split(DELIMITER);
    return {
        satoshis: satoshis ? parseInt(satoshis) : 0,
        vout: parseInt(vout),
        txid,
        token: tokenId
            ? {
                tokenId,
                amount: parseInt(amount),
                capability: capability || undefined,
                commitment: commitment || undefined,
            }
            : undefined,
    };
};
export const toUtxoId = (utxo) => {
    return [
        utxo.txid,
        utxo.vout,
        utxo.satoshis,
        utxo.token?.tokenId,
        utxo.token?.amount,
        utxo.token?.capability,
        utxo.token?.commitment,
    ]
        .join(DELIMITER)
        .replace(/:+$/, "");
};
//# sourceMappingURL=model.js.map