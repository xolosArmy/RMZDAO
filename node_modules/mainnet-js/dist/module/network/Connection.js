import { getNetworkProvider, setGlobalProvider, getGlobalProvider, removeGlobalProvider, } from "./default.js";
import { networkTickerMap } from "./constant.js";
import { prefixFromNetworkMap } from "../enum.js";
export async function initProvider(network) {
    if (!getGlobalProvider(network)) {
        const conn = new Connection(network);
        const provider = (await conn.ready()).networkProvider;
        setGlobalProvider(network, provider);
        return provider;
    }
    return getGlobalProvider(network);
}
export async function initProviders(networks) {
    networks = networks ? networks : Object.keys(networkTickerMap);
    let initPromises = networks.map((n) => initProvider(n));
    await Promise.all(initPromises).catch((e) => {
        console.warn(`Warning, couldn't establish a connection for ${e}`);
    });
}
async function disconnectProvider(network) {
    const provider = getGlobalProvider(network);
    if (provider) {
        await provider.disconnect();
        removeGlobalProvider(network);
        return;
    }
    else {
        // console.warn(
        //   `Ignoring attempt to disconnect non-existent ${network} provider`
        // );
        return true;
    }
}
export async function disconnectProviders(networks) {
    networks = networks ? networks : Object.keys(networkTickerMap);
    let disconnectPromises = networks.map((n) => disconnectProvider(n));
    await Promise.all(disconnectPromises);
}
export class Connection {
    constructor(network, servers) {
        this.network = network ? network : "mainnet";
        this.networkPrefix = prefixFromNetworkMap[this.network];
        this.networkProvider = getNetworkProvider(this.network, servers, true);
    }
    async ready() {
        await this.networkProvider.connect();
        await this.networkProvider.ready();
        return this;
    }
    async disconnect() {
        await this.networkProvider.disconnect();
        return this;
    }
}
//# sourceMappingURL=Connection.js.map