'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var debug$1 = require('debug');
var events = require('events');
var tls = require('tls');
var net = require('net');
var WebSocket = require('isomorphic-ws');
var asyncMutex = require('async-mutex');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var tls__default = /*#__PURE__*/_interopDefaultLegacy(tls);
var net__default = /*#__PURE__*/_interopDefaultLegacy(net);
var WebSocket__default = /*#__PURE__*/_interopDefaultLegacy(WebSocket);

// Create the debug logs.
const debug = {
    client: debug$1.debug('electrum-cash:client '),
    cluster: debug$1.debug('electrum-cash:cluster'),
    errors: debug$1.debug('electrum-cash:error  '),
    warning: debug$1.debug('electrum-cash:warning'),
    network: debug$1.debug('electrum-cash:network'),
    ping: debug$1.debug('electrum-cash:pulses '),
};
// Set log colors.
debug.client.color = '2';
debug.cluster.color = '3';
debug.errors.color = '9';
debug.warning.color = '13';
debug.network.color = '4';
debug.ping.color = '8';

/**
 * Grouping of utilities that simplifies implementation of the Electrum protocol.
 *
 * @ignore
 */
class ElectrumProtocol {
    /**
     * Helper function that builds an Electrum request object.
     *
     * @param {string} method       method to call.
     * @param {array}  parameters   method parameters for the call.
     * @param {string} requestId    unique string or number referencing this request.
     *
     * @returns a properly formatted Electrum request string.
     */
    static buildRequestObject(method, parameters, requestId) {
        // Return the formatted request object.
        // NOTE: Electrum either uses JsonRPC strictly or loosely.
        //       If we specify protocol identifier without being 100% compliant, we risk being disconnected/blacklisted.
        //       For this reason, we omit the protocol identifier to avoid issues.
        return JSON.stringify({ method: method, params: parameters, id: requestId });
    }
    /**
     * Constant used to verify if a provided string is a valid version number.
     *
     * @returns a regular expression that matches valid version numbers.
     */
    static get versionRegexp() {
        return /^\d+(\.\d+)+$/;
    }
    /**
     * Constant used to separate statements/messages in a stream of data.
     *
     * @returns the delimiter used by Electrum to separate statements.
     */
    static get statementDelimiter() {
        return '\n';
    }
}

const isVersionRejected = function (object) {
    return 'error' in object;
};
const isVersionNegotiated = function (object) {
    return 'software' in object && 'protocol' in object;
};

// Disable indent rule for this file because it is broken (https://github.com/typescript-eslint/typescript-eslint/issues/1824)
/* eslint-disable @typescript-eslint/indent */
/**
 * Enum that denotes the ordering to use in an ElectrumCluster.
 * @enum {number}
 * @property {0} RANDOM     Send requests to randomly selected servers in the cluster.
 * @property {1} PRIORITY   Send requests to servers in the cluster in the order they were added.
 */
exports.ClusterOrder = void 0;
(function (ClusterOrder) {
    ClusterOrder[ClusterOrder["RANDOM"] = 0] = "RANDOM";
    ClusterOrder[ClusterOrder["PRIORITY"] = 1] = "PRIORITY";
})(exports.ClusterOrder || (exports.ClusterOrder = {}));
/**
 * Enum that denotes the distribution setting to use in an ElectrumCluster.
 * @enum {number}
 * @property {0} ALL   Send requests to all servers in the cluster.
 */
exports.ClusterDistribution = void 0;
(function (ClusterDistribution) {
    ClusterDistribution[ClusterDistribution["ALL"] = 0] = "ALL";
})(exports.ClusterDistribution || (exports.ClusterDistribution = {}));
/**
 * Enum that denotes the ready status of an ElectrumCluster.
 * @enum {number}
 * @property {0} DISABLED    The cluster is disabled and unusable.
 * @property {1} DEGRADED    The cluster is degraded but still usable.
 * @property {2} READY       The cluster is healthy and ready for use.
 */
exports.ClusterStatus = void 0;
(function (ClusterStatus) {
    ClusterStatus[ClusterStatus["DISABLED"] = 0] = "DISABLED";
    ClusterStatus[ClusterStatus["DEGRADED"] = 1] = "DEGRADED";
    ClusterStatus[ClusterStatus["READY"] = 2] = "READY";
})(exports.ClusterStatus || (exports.ClusterStatus = {}));
/**
 * Enum that denotes the availability of an ElectrumClient.
 * @enum {number}
 * @property {0} UNAVAILABLE   The client is currently not available.
 * @property {1} AVAILABLE     The client is available for use.
 */
exports.ClientState = void 0;
(function (ClientState) {
    ClientState[ClientState["UNAVAILABLE"] = 0] = "UNAVAILABLE";
    ClientState[ClientState["AVAILABLE"] = 1] = "AVAILABLE";
})(exports.ClientState || (exports.ClientState = {}));
/**
 * Enum that denotes the connection status of an ElectrumConnection.
 * @enum {number}
 * @property {0} DISCONNECTED    The connection is disconnected.
 * @property {1} AVAILABLE       The connection is connected.
 * @property {2} DISCONNECTING   The connection is disconnecting.
 * @property {3} CONNECTING      The connection is connecting.
 * @property {4} RECONNECTING    The connection is restarting.
 */
exports.ConnectionStatus = void 0;
(function (ConnectionStatus) {
    ConnectionStatus[ConnectionStatus["DISCONNECTED"] = 0] = "DISCONNECTED";
    ConnectionStatus[ConnectionStatus["CONNECTED"] = 1] = "CONNECTED";
    ConnectionStatus[ConnectionStatus["DISCONNECTING"] = 2] = "DISCONNECTING";
    ConnectionStatus[ConnectionStatus["CONNECTING"] = 3] = "CONNECTING";
    ConnectionStatus[ConnectionStatus["RECONNECTING"] = 4] = "RECONNECTING";
})(exports.ConnectionStatus || (exports.ConnectionStatus = {}));

/**
 * Object containing the commonly used ports and schemes for specific Transports.
 * @example const electrum = new ElectrumClient('Electrum client example', '1.4.1', 'bch.imaginary.cash', Transport.WSS.Port, Transport.WSS.Scheme);
 *
 * @property {object} TCP       Port and Scheme to use unencrypted TCP sockets.
 * @property {object} TCP_TLS   Port and Scheme to use TLS-encrypted TCP sockets.
 * @property {object} WS        Port and Scheme to use unencrypted WebSockets.
 * @property {object} WSS       Port and Scheme to use TLS-encrypted WebSockets.
 */
const ElectrumTransport = {
    TCP: { Port: 50001, Scheme: 'tcp' },
    TCP_TLS: { Port: 50002, Scheme: 'tcp_tls' },
    WS: { Port: 50003, Scheme: 'ws' },
    WSS: { Port: 50004, Scheme: 'wss' },
};
const DefaultParameters = {
    // Port number for TCP TLS connections
    PORT: ElectrumTransport.TCP_TLS.Port,
    // Transport to connect to the Electrum server
    TRANSPORT_SCHEME: ElectrumTransport.TCP_TLS.Scheme,
    // How long to wait before attempting to reconnect, in milliseconds.
    RECONNECT: 15 * 1000,
    // How long to wait for network operations before following up, in milliseconds.
    TIMEOUT: 120 * 1000,
    // Time between ping messages, in milliseconds. Pinging keeps the connection alive.
    // The reason for pinging this frequently is to detect connection problems early.
    PING_INTERVAL: 3 * 1000,
    // How many servers are required before we trust information provided.
    CLUSTER_CONFIDENCE: 1,
    // How many servers we send requests to.
    CLUSTER_DISTRIBUTION: exports.ClusterDistribution.ALL,
    // What order we select servers to send requests to.
    CLUSTER_ORDER: exports.ClusterOrder.RANDOM,
};

/**
 * Isomorphic Socket interface supporting TCP sockets and WebSockets (Node and browser).
 * The interface is a subset of the TLSSocket interface with some slight modifications.
 * It can be expanded when more socket functionality is needed in the rest of the
 * electrum-cash code. Changes from the TLSSocket interface (besides it being a subset):
 * - Event 'close' -> 'disconnect'
 * - New function socket.disconnect()
 *
 * @ignore
 */
class ElectrumSocket extends events.EventEmitter {
    // Declare an empty TCP socket.
    tcpSocket;
    // Declare an empty WebSocket.
    webSocket;
    // Declare timers for keep-alive pings and reconnection
    timers = {};
    // Initialize boolean that indicates whether the onConnect function has run (initialize to false).
    onConnectHasRun = false;
    // Initialize event forwarding functions.
    eventForwarders = {
        disconnect: () => this.emit('disconnect'),
        tcpData: (data) => this.emit('data', data),
        wsData: (event) => this.emit('data', `${event.data}\n`),
        tcpError: (err) => this.emit('error', err),
        wsError: (event) => this.emit('error', event.error),
    };
    /**
     * Connect to host:port using the specified transport
     *
     * @param {string} host              Fully qualified domain name or IP address of the host
     * @param {number} port              Network port for the host to connect to
     * @param {TransportScheme} scheme   Transport scheme to use
     * @param {number} timeout           If no connection is established after `timeout` ms, the connection is terminated
     *
     * @throws {Error} if an incorrect transport scheme is specified
     */
    connect(host, port, scheme, timeout) {
        // Check that no existing socket exists before initiating a new connection.
        if (this.tcpSocket || this.webSocket) {
            throw (new Error('Cannot initiate a new socket connection when an existing connection exists'));
        }
        // Set a timer to force disconnect after `timeout` seconds
        this.timers.disconnect = setTimeout(() => this.disconnectOnTimeout(host, port, timeout), timeout);
        // Remove the timer if a connection is successfully established
        this.once('connect', this.clearDisconnectTimerOnTimeout);
        // Define how to refer to the connection scheme in debug output.
        const socketTypes = {
            [ElectrumTransport.TCP.Scheme]: 'a TCP Socket',
            [ElectrumTransport.TCP_TLS.Scheme]: 'an encrypted TCP socket',
            [ElectrumTransport.WS.Scheme]: 'a WebSocket',
            [ElectrumTransport.WSS.Scheme]: 'an encrypted WebSocket',
        };
        // Log that we are trying to establish a connection.
        debug.network(`Initiating ${socketTypes[scheme]} connection to '${host}:${port}'.`);
        if (scheme === ElectrumTransport.TCP.Scheme || scheme === ElectrumTransport.TCP_TLS.Scheme) {
            if (scheme === ElectrumTransport.TCP_TLS.Scheme) {
                // Initialize connection options.
                const connectionOptions = { rejectUnauthorized: false };
                // If the hostname is not an IP address..
                if (!net__default['default'].isIP(host)) {
                    // Set the servername option which enables support for SNI.
                    // NOTE: SNI enables a server that hosts multiple domains to provide the appropriate TLS certificate.
                    connectionOptions.serverName = host;
                }
                // Initialize this.tcpSocket (allowing self-signed certificates).
                this.tcpSocket = tls__default['default'].connect(port, host, connectionOptions);
                // Add a 'secureConnect' listener that checks the authorization status of
                // the socket, and logs a warning when it uses a self signed certificate.
                this.tcpSocket.once('secureConnect', () => {
                    // Cannot happen, since this event callback *only* exists on TLSSocket
                    if (!(this.tcpSocket instanceof tls__default['default'].TLSSocket))
                        return;
                    // Force cast authorizationError from Error to string (through unknown)
                    // because it is incorrectly typed as an Error
                    const authorizationError = this.tcpSocket.authorizationError;
                    if (authorizationError === 'DEPTH_ZERO_SELF_SIGNED_CERT') {
                        debug.warning(`Connection to ${host}:${port} uses a self-signed certificate`);
                    }
                });
                // Trigger successful connection events.
                this.tcpSocket.on('secureConnect', this.onConnect.bind(this, socketTypes[scheme], host, port));
            }
            else {
                // Initialize this.tcpSocket.
                this.tcpSocket = net__default['default'].connect({ host, port });
                // Trigger successful connection events.
                this.tcpSocket.on('connect', this.onConnect.bind(this, socketTypes[scheme], host, port));
            }
            // Configure encoding.
            this.tcpSocket.setEncoding('utf8');
            // Enable persistent connections with an initial delay of 0.
            this.tcpSocket.setKeepAlive(true, 0);
            // Disable buffering of outgoing data.
            this.tcpSocket.setNoDelay(true);
            // Forward the encountered errors.
            this.tcpSocket.on('error', this.eventForwarders.tcpError);
        }
        else if (scheme === ElectrumTransport.WS.Scheme || scheme === ElectrumTransport.WSS.Scheme) {
            if (scheme === ElectrumTransport.WSS.Scheme) {
                // Initialize this.webSocket (rejecting self-signed certificates).
                // We reject self-signed certificates to match functionality of browsers.
                this.webSocket = new WebSocket__default['default'](`wss://${host}:${port}`);
            }
            else {
                // Initialize this.webSocket.
                this.webSocket = new WebSocket__default['default'](`ws://${host}:${port}`);
            }
            // Trigger successful connection events.
            this.webSocket.addEventListener('open', this.onConnect.bind(this, socketTypes[scheme], host, port));
            // Forward the encountered errors.
            this.webSocket.addEventListener('error', this.eventForwarders.wsError);
        }
        else {
            // Throw an error if an incorrect transport is specified
            throw (new Error('Incorrect transport specified'));
        }
    }
    /**
     * Sets up forwarding of events related to the connection.
     *
     * @param {string} connectionType   Name of the connection/transport type, used for logging.
     * @param {string} host             Fully qualified domain name or IP address of the host
     * @param {number} port             Network port for the host to connect to
     */
    onConnect(connectionType, host, port) {
        // If the onConnect function has already run, do not execute it again.
        if (this.onConnectHasRun)
            return;
        // Log that the connection has been established.
        debug.network(`Established ${connectionType} connection with '${host}:${port}'.`);
        if (typeof this.tcpSocket !== 'undefined') {
            // Forward the socket events
            this.tcpSocket.addListener('close', this.eventForwarders.disconnect);
            this.tcpSocket.addListener('data', this.eventForwarders.tcpData);
        }
        else if (typeof this.webSocket !== 'undefined') {
            // Forward the socket events
            this.webSocket.addEventListener('close', this.eventForwarders.disconnect);
            this.webSocket.addEventListener('message', this.eventForwarders.wsData);
        }
        // Indicate that the onConnect function has run.
        this.onConnectHasRun = true;
        // Emit the connect event.
        this.emit('connect');
    }
    /**
     * Clears the disconnect timer if it is still active.
     */
    clearDisconnectTimerOnTimeout() {
        // Clear the retry timer if it is still active.
        if (this.timers.disconnect) {
            clearTimeout(this.timers.disconnect);
        }
    }
    /**
     * Forcibly terminate the connection.
     *
     * @throws {Error} if no connection was found
     */
    disconnect() {
        // Clear the disconnect timer so that the socket does not try to disconnect again later.
        this.clearDisconnectTimerOnTimeout();
        // Handle disconnect based differently depending on socket type.
        if (this.tcpSocket) {
            // Remove all event forwarders.
            this.tcpSocket.removeListener('close', this.eventForwarders.disconnect);
            this.tcpSocket.removeListener('data', this.eventForwarders.tcpData);
            this.tcpSocket.removeListener('error', this.eventForwarders.tcpError);
            // Terminate the connection.
            this.tcpSocket.destroy();
            // Remove the stored socket.
            this.tcpSocket = undefined;
        }
        else if (this.webSocket) {
            try {
                // Remove all event forwarders.
                this.webSocket.removeEventListener('close', this.eventForwarders.disconnect);
                this.webSocket.removeEventListener('message', this.eventForwarders.wsData);
                this.webSocket.removeEventListener('error', this.eventForwarders.wsError);
                // Gracefully terminate the connection.
                this.webSocket.close();
            }
            catch (ignored) {
                // close() will throw an error if the connection has not been established yet.
                // We ignore this error, since no similar error gets thrown in the TLS Socket.
            }
            finally {
                // Remove the stored socket regardless of any thrown errors.
                this.webSocket = undefined;
            }
        }
        // Indicate that the onConnect function has not run and it has to be run again.
        this.onConnectHasRun = false;
        // Emit a disconnect event
        this.emit('disconnect');
    }
    /**
     * Write data to the socket
     *
     * @param {Uint8Array | string} data   Data to be written to the socket
     * @param {function} callback          Callback function to be called when the write has completed
     *
     * @throws {Error} if no connection was found
     * @returns true if the message was fully flushed to the socket, false if part of the message
     * is queued in the user memory
     */
    write(data, callback) {
        if (this.tcpSocket) {
            // Write data to the TLS Socket and return the status indicating whether the
            // full message was flushed to the socket
            return this.tcpSocket.write(data, callback);
        }
        if (this.webSocket) {
            // Write data to the WebSocket
            this.webSocket.send(data, callback);
            // WebSockets always fit everything in a single request, so we return true
            return true;
        }
        // Throw an error if no active connection is found
        throw (new Error('Cannot write to socket when there is no active connection'));
    }
    /**
     * Force a disconnection if no connection is established after `timeout` milliseconds.
     *
     * @param {string} host      Host of the connection that timed out
     * @param {number} port      Port of the connection that timed out
     * @param {number} timeout   Elapsed milliseconds
     */
    disconnectOnTimeout(host, port, timeout) {
        // Remove the connect listener.
        this.removeListener('connect', this.clearDisconnectTimerOnTimeout);
        // Create a new timeout error.
        const timeoutError = { code: 'ETIMEDOUT', message: `Connection to '${host}:${port}' timed out after ${timeout} milliseconds` };
        // Emit an error event so that connect is rejected upstream.
        this.emit('error', timeoutError);
        // Forcibly disconnect to clean up the connection on timeout
        this.disconnect();
    }
}

/**
 * Wrapper around TLS/WSS sockets that gracefully separates a network stream into Electrum protocol messages.
 *
 * @ignore
 */
class ElectrumConnection extends events.EventEmitter {
    application;
    version;
    host;
    port;
    scheme;
    timeout;
    pingInterval;
    // Declare an empty socket.
    socket;
    // Declare empty timestamps
    lastReceivedTimestamp;
    // Declare timers for keep-alive pings and reconnection
    timers = {};
    // Initialize an empty array of connection verification timers.
    // eslint-disable-next-line no-undef
    verifications = [];
    // Initialize the connected flag to false to indicate that there is no connection
    status = exports.ConnectionStatus.DISCONNECTED;
    // Initialize messageBuffer to an empty string
    messageBuffer = '';
    /**
     * Sets up network configuration for an Electrum client connection.
     *
     * @param {string} application       your application name, used to identify to the electrum host.
     * @param {string} version           protocol version to use with the host.
     * @param {string} host              fully qualified domain name or IP number of the host.
     * @param {number} port              the network port of the host.
     * @param {TransportScheme} scheme   the transport scheme to use for connection
     * @param {number} timeout           how long network delays we will wait for before taking action, in milliseconds.
     * @param {number} pingInterval      the time between sending pings to the electrum host, in milliseconds.
     *
     * @throws {Error} if `version` is not a valid version string.
     */
    constructor(application, version, host, port = DefaultParameters.PORT, scheme = DefaultParameters.TRANSPORT_SCHEME, timeout = DefaultParameters.TIMEOUT, pingInterval = DefaultParameters.PING_INTERVAL) {
        // Initialize the event emitter.
        super();
        this.application = application;
        this.version = version;
        this.host = host;
        this.port = port;
        this.scheme = scheme;
        this.timeout = timeout;
        this.pingInterval = pingInterval;
        // Check if the provided version is a valid version number.
        if (!ElectrumProtocol.versionRegexp.test(version)) {
            // Throw an error since the version number was not valid.
            throw (new Error(`Provided version string (${version}) is not a valid protocol version number.`));
        }
        // Create an initial network socket.
        this.createSocket();
    }
    /**
     * Returns a string for the host identifier for usage in debug messages.
     */
    get hostIdentifier() {
        return `${this.host}:${this.port}`;
    }
    /**
     * Create and configures a fresh socket and attaches all relevant listeners.
     */
    createSocket() {
        // Initialize a new ElectrumSocket
        this.socket = new ElectrumSocket();
        // Set up handlers for connection and disconnection.
        this.socket.on('connect', this.onSocketConnect.bind(this));
        this.socket.on('disconnect', this.onSocketDisconnect.bind(this));
        // Set up handler for incoming data.
        this.socket.on('data', this.parseMessageChunk.bind(this));
    }
    /**
     * Shuts down and destroys the current socket.
     */
    destroySocket() {
        // Close the socket connection and destroy the socket.
        this.socket.disconnect();
    }
    /**
     * Assembles incoming data into statements and hands them off to the message parser.
     *
     * @param {string} data   data to append to the current message buffer, as a string.
     *
     * @throws {SyntaxError} if the passed statement parts are not valid JSON.
     */
    parseMessageChunk(data) {
        // Update the timestamp for when we last received data.
        this.lastReceivedTimestamp = Date.now();
        // Clear and remove all verification timers.
        this.verifications.forEach((timer) => clearTimeout(timer));
        this.verifications.length = 0;
        // Add the message to the current message buffer.
        this.messageBuffer += data;
        // Check if the new message buffer contains the statement delimiter.
        while (this.messageBuffer.includes(ElectrumProtocol.statementDelimiter)) {
            // Split message buffer into statements.
            const statementParts = this.messageBuffer.split(ElectrumProtocol.statementDelimiter);
            // For as long as we still have statements to parse..
            while (statementParts.length > 1) {
                // Move the first statement to its own variable.
                const currentStatementList = String(statementParts.shift());
                // Parse the statement into an object or list of objects.
                let statementList = JSON.parse(currentStatementList);
                // Wrap the statement in an array if it is not already a batched statement list.
                if (!Array.isArray(statementList)) {
                    statementList = [statementList];
                }
                // For as long as there is statements in the result set..
                while (statementList.length > 0) {
                    // Move the first statement from the batch to its own variable.
                    const currentStatement = statementList.shift();
                    // If the current statement is a version negotiation response..
                    if (currentStatement.id === 'versionNegotiation') {
                        if (currentStatement.error) {
                            // Then emit a failed version negotiation response signal.
                            this.emit('version', { error: currentStatement.error });
                        }
                        else {
                            // Emit a successful version negotiation response signal.
                            this.emit('version', { software: currentStatement.result[0], protocol: currentStatement.result[1] });
                        }
                        // Consider this statement handled.
                        continue;
                    }
                    // If the current statement is a keep-alive response..
                    if (currentStatement.id === 'keepAlive') {
                        // Do nothing and consider this statement handled.
                        continue;
                    }
                    // Emit the statements for handling higher up in the stack.
                    this.emit('statement', currentStatement);
                }
            }
            // Store the remaining statement as the current message buffer.
            this.messageBuffer = statementParts.shift() || '';
        }
    }
    /**
     * Sends a keep-alive message to the host.
     *
     * @returns true if the ping message was fully flushed to the socket, false if
     * part of the message is queued in the user memory
     */
    ping() {
        // Write a log message.
        debug.ping(`Sending keep-alive ping to '${this.hostIdentifier}'`);
        // Craft a keep-alive message.
        const message = ElectrumProtocol.buildRequestObject('server.ping', [], 'keepAlive');
        // Send the keep-alive message.
        const status = this.send(message);
        // Return the ping status.
        return status;
    }
    /**
     * Initiates the network connection negotiates a protocol version. Also emits the 'connect' signal if successful.
     *
     * @throws {Error} if the socket connection fails.
     * @returns a promise resolving when the connection is established
     */
    async connect() {
        // If we are already connected return true.
        if (this.status === exports.ConnectionStatus.CONNECTED) {
            return;
        }
        // Indicate that the connection is connecting
        this.status = exports.ConnectionStatus.CONNECTING;
        // Define a function to wrap connection as a promise.
        const connectionResolver = (resolve, reject) => {
            const rejector = (error) => {
                // Set the status back to disconnected
                this.status = exports.ConnectionStatus.DISCONNECTED;
                // Reject with the error as reason
                reject(error);
            };
            // Replace previous error handlers to reject the promise on failure.
            this.socket.removeAllListeners('error');
            this.socket.once('error', rejector);
            // Define a function to wrap version negotiation as a callback.
            const versionNegotiator = () => {
                // Write a log message to show that we have started version negotiation.
                debug.network(`Requesting protocol version ${this.version} with '${this.hostIdentifier}'.`);
                // remove the one-time error handler since no error was detected.
                this.socket.removeListener('error', rejector);
                // Build a version negotiation message.
                const versionMessage = ElectrumProtocol.buildRequestObject('server.version', [this.application, this.version], 'versionNegotiation');
                // Define a function to wrap version validation as a function.
                const versionValidator = (version) => {
                    // Check if version negotiation failed.
                    if (isVersionRejected(version)) {
                        // Disconnect from the host.
                        this.disconnect(true);
                        // Declare an error message.
                        const errorMessage = 'unsupported protocol version.';
                        // Log the error.
                        debug.errors(`Failed to connect with ${this.hostIdentifier} due to ${errorMessage}`);
                        // Reject the connection with false since version negotiation failed.
                        reject(errorMessage);
                    }
                    // Check if the host supports our requested protocol version.
                    else if (version.protocol !== this.version) {
                        // Disconnect from the host.
                        this.disconnect(true);
                        // Declare an error message.
                        const errorMessage = `incompatible protocol version negotiated (${version.protocol} !== ${this.version}).`;
                        // Log the error.
                        debug.errors(`Failed to connect with ${this.hostIdentifier} due to ${errorMessage}`);
                        // Reject the connection with false since version negotiation failed.
                        reject(errorMessage);
                    }
                    else {
                        // Write a log message.
                        debug.network(`Negotiated protocol version ${version.protocol} with '${this.hostIdentifier}', powered by ${version.software}.`);
                        // Set connection status to connected
                        this.status = exports.ConnectionStatus.CONNECTED;
                        // Emit a connect event now that the connection is usable.
                        this.emit('connect');
                        // Resolve the connection promise since we successfully connected and negotiated protocol version.
                        resolve();
                    }
                };
                // Listen for version negotiation once.
                this.once('version', versionValidator);
                // Send the version negotiation message.
                this.send(versionMessage);
            };
            // Prepare the version negotiation.
            this.socket.once('connect', versionNegotiator);
            // Set up handler for network errors.
            this.socket.on('error', this.onSocketError.bind(this));
            // Connect to the server.
            this.socket.connect(this.host, this.port, this.scheme, this.timeout);
        };
        // Wait until connection is established and version negotiation succeeds.
        await new Promise(connectionResolver);
    }
    /**
     * Restores the network connection.
     */
    async reconnect() {
        // If a reconnect timer is set, remove it
        await this.clearReconnectTimer();
        // Write a log message.
        debug.network(`Trying to reconnect to '${this.hostIdentifier}'..`);
        // Set the status to reconnecting for more accurate log messages.
        this.status = exports.ConnectionStatus.RECONNECTING;
        // Destroy and recreate the socket to get a clean slate.
        this.destroySocket();
        this.createSocket();
        try {
            // Try to connect again.
            await this.connect();
        }
        catch (error) {
            // Do nothing as the error should be handled via the disconnect and error signals.
        }
    }
    /**
     * Removes the current reconnect timer.
     */
    clearReconnectTimer() {
        // If a reconnect timer is set, remove it
        if (this.timers.reconnect) {
            clearTimeout(this.timers.reconnect);
        }
        // Reset the timer reference.
        this.timers.reconnect = undefined;
    }
    /**
     * Removes the current keep-alive timer.
     */
    clearKeepAliveTimer() {
        // If a keep-alive timer is set, remove it
        if (this.timers.keepAlive) {
            clearTimeout(this.timers.keepAlive);
        }
        // Reset the timer reference.
        this.timers.keepAlive = undefined;
    }
    /**
     * Initializes the keep alive timer loop.
     */
    setupKeepAliveTimer() {
        // If the keep-alive timer loop is not currently set up..
        if (!this.timers.keepAlive) {
            // Set a new keep-alive timer.
            this.timers.keepAlive = setTimeout(this.ping.bind(this), this.pingInterval);
        }
    }
    /**
     * Tears down the current connection and removes all event listeners on disconnect.
     *
     * @param {boolean} force   disconnect even if the connection has not been fully established yet.
     *
     * @returns true if successfully disconnected, or false if there was no connection.
     */
    async disconnect(force = false) {
        // Return early when there is nothing to disconnect from
        if (this.status === exports.ConnectionStatus.DISCONNECTED && !force) {
            // Return false to indicate that there was nothing to disconnect from.
            return false;
        }
        // Set connection status to null to indicate tear-down is currently happening.
        this.status = exports.ConnectionStatus.DISCONNECTING;
        // If a keep-alive timer is set, remove it.
        await this.clearKeepAliveTimer();
        // If a reconnect timer is set, remove it
        await this.clearReconnectTimer();
        const disconnectResolver = (resolve) => {
            // Resolve to true after the connection emits a disconnect
            this.once('disconnect', () => resolve(true));
            // Close the connection and destroy the socket.
            this.destroySocket();
        };
        // Return true to indicate that we disconnected.
        return new Promise(disconnectResolver);
    }
    /**
     * Sends an arbitrary message to the server.
     *
     * @param {string} message   json encoded request object to send to the server, as a string.
     *
     * @returns true if the message was fully flushed to the socket, false if part of the message
     * is queued in the user memory
     */
    send(message) {
        // Remove the current keep-alive timer if it exists.
        this.clearKeepAliveTimer();
        // Get the current timestamp in milliseconds.
        const currentTime = Date.now();
        // Follow up and verify that the message got sent..
        const verificationTimer = setTimeout(this.verifySend.bind(this, currentTime), this.timeout);
        // Store the verification timer locally so that it can be cleared when data has been received.
        this.verifications.push(verificationTimer);
        // Set a new keep-alive timer.
        this.setupKeepAliveTimer();
        // Write the message to the network socket.
        return this.socket.write(message + ElectrumProtocol.statementDelimiter);
    }
    // --- Event managers. --- //
    /**
     * Marks the connection as timed out and schedules reconnection if we have not
     * received data within the expected time frame.
     */
    verifySend(sentTimestamp) {
        // If we haven't received any data since we last sent data out..
        if (Number(this.lastReceivedTimestamp) < sentTimestamp) {
            // If this connection is already disconnected, we do not change anything
            if ((this.status === exports.ConnectionStatus.DISCONNECTED) || (this.status === exports.ConnectionStatus.DISCONNECTING)) {
                debug.errors(`Tried to verify already disconnected connection to '${this.hostIdentifier}'`);
                return;
            }
            // Remove the current keep-alive timer if it exists.
            this.clearKeepAliveTimer();
            // Write a notification to the logs.
            debug.network(`Connection to '${this.hostIdentifier}' timed out.`);
            // Close the connection to avoid re-use.
            // NOTE: This initiates reconnection routines if the connection has not
            //       been marked as intentionally disconnected.
            this.socket.disconnect();
        }
    }
    /**
     * Updates the connection status when a connection is confirmed.
     */
    onSocketConnect() {
        // If a reconnect timer is set, remove it.
        this.clearReconnectTimer();
        // Set up the initial timestamp for when we last received data from the server.
        this.lastReceivedTimestamp = Date.now();
        // Set up the initial keep-alive timer.
        this.setupKeepAliveTimer();
        // Clear all temporary error listeners.
        this.socket.removeAllListeners('error');
        // Set up handler for network errors.
        this.socket.on('error', this.onSocketError.bind(this));
    }
    /**
     * Updates the connection status when a connection is ended.
     */
    onSocketDisconnect() {
        // Send a disconnect signal higher up the stack.
        this.emit('disconnect');
        // Remove the current keep-alive timer if it exists.
        this.clearKeepAliveTimer();
        // If this is a connection we're trying to tear down..
        if (this.status === exports.ConnectionStatus.DISCONNECTING) {
            // If a reconnect timer is set, remove it.
            this.clearReconnectTimer();
            // Remove all event listeners
            this.removeAllListeners();
            // Mark the connection as disconnected.
            this.status = exports.ConnectionStatus.DISCONNECTED;
            // Write a log message.
            debug.network(`Disconnected from '${this.hostIdentifier}'.`);
        }
        else {
            // If this is for an established connection..
            if (this.status === exports.ConnectionStatus.CONNECTED) {
                // Write a notification to the logs.
                debug.errors(`Connection with '${this.hostIdentifier}' was closed, trying to reconnect in ${DefaultParameters.RECONNECT / 1000} seconds.`);
            }
            // Mark the connection as disconnected for now..
            this.status = exports.ConnectionStatus.DISCONNECTED;
            // If we don't have a pending reconnection timer..
            if (!this.timers.reconnect) {
                // Attempt to reconnect after one keep-alive duration.
                this.timers.reconnect = setTimeout(this.reconnect.bind(this), DefaultParameters.RECONNECT);
            }
        }
    }
    /**
     * Notify administrator of any unexpected errors.
     */
    onSocketError(error) {
        // Report a generic error if no error information is present.
        // NOTE: When using WSS, the error event explicitly
        //       only allows to send a "simple" event without data.
        //       https://stackoverflow.com/a/18804298
        if (typeof error === 'undefined') {
            // Do nothing, and instead rely on the socket disconnect event for further information.
            return;
        }
        // If the DNS lookup failed.
        if (error.code === 'EAI_AGAIN') {
            debug.errors(`Failed to look up DNS records for '${this.host}'.`);
            return;
        }
        // If the connection timed out..
        if (error.code === 'ETIMEDOUT') {
            // Log the provided timeout message.
            debug.errors(error.message);
            return;
        }
        // Log unknown error
        debug.errors(`Unknown network error ('${this.hostIdentifier}'): `, error);
    }
}

const isRPCErrorResponse = function (message) {
    return 'id' in message && 'error' in message;
};
const isRPCNotification = function (message) {
    return !('id' in message) && 'method' in message;
};

/**
 * Triggers when the underlying connection is established.
 *
 * @event ElectrumClient#connected
 */
/**
 * Triggers when the underlying connection is lost.
 *
 * @event ElectrumClient#disconnected
 */
/**
 * High-level Electrum client that lets applications send requests and subscribe to notification events from a server.
 */
class ElectrumClient extends events.EventEmitter {
    // Declare instance variables
    connection;
    // Initialize an empty list of subscription metadata.
    subscriptionMethods = {};
    subscriptionCallbacks = new WeakMap();
    // Start counting the request IDs from 0
    requestId = 0;
    // Initialize an empty dictionary for keeping track of request resolvers
    requestResolvers = {};
    /**
     * Initializes an Electrum client.
     *
     * @param {string} application       your application name, used to identify to the electrum host.
     * @param {string} version           protocol version to use with the host.
     * @param {string} host              fully qualified domain name or IP number of the host.
     * @param {number} port              the TCP network port of the host.
     * @param {TransportScheme} scheme   the transport scheme to use for connection
     * @param {number} timeout           how long network delays we will wait for before taking action, in milliseconds.
     * @param {number} pingInterval      the time between sending pings to the electrum host, in milliseconds.
     *
     * @throws {Error} if `version` is not a valid version string.
     */
    constructor(application, version, host, port = DefaultParameters.PORT, scheme = DefaultParameters.TRANSPORT_SCHEME, timeout = DefaultParameters.TIMEOUT, pingInterval = DefaultParameters.PING_INTERVAL) {
        // Initialize the event emitter.
        super();
        // Set up a connection to an electrum server.
        this.connection = new ElectrumConnection(application, version, host, port, scheme, timeout, pingInterval);
    }
    /**
     * Connects to the remote server.
     *
     * @throws {Error} if the socket connection fails.
     * @returns a promise resolving when the connection is established.
     */
    async connect() {
        // Listen for parsed statements.
        this.connection.on('statement', this.response.bind(this));
        // Hook up resubscription on connection.
        this.connection.on('connect', this.resubscribeOnConnect.bind(this));
        // Relay connect and disconnect events.
        this.connection.on('connect', this.emit.bind(this, 'connected'));
        this.connection.on('disconnect', this.onConnectionDisconnect.bind(this));
        // Relay error events.
        this.connection.on('error', this.emit.bind(this, 'error'));
        // Connect with the server.
        await this.connection.connect();
    }
    /**
     * Disconnects from the remote server and removes all event listeners/subscriptions and open requests.
     *
     * @param {boolean} force                 disconnect even if the connection has not been fully established yet.
     * @param {boolean} retainSubscriptions   retain subscription data so they will be restored on reconnection.
     *
     * @returns true if successfully disconnected, or false if there was no connection.
     */
    async disconnect(force = false, retainSubscriptions = false) {
        if (!retainSubscriptions) {
            // Cancel all event listeners.
            this.removeAllListeners();
            // Remove all subscription data
            this.subscriptionMethods = {};
        }
        // For each pending request..
        for (const index in this.requestResolvers) {
            // Reject the request.
            const requestResolver = this.requestResolvers[index];
            requestResolver(new Error('Manual disconnection'));
            // Remove the request.
            delete this.requestResolvers[index];
        }
        // Disconnect from the remove server.
        return this.connection.disconnect(force);
    }
    /**
     * Calls a method on the remote server with the supplied parameters.
     *
     * @param {string} method          name of the method to call.
     * @param {...string} parameters   one or more parameters for the method.
     *
     * @throws {Error} if the client is disconnected.
     * @returns a promise that resolves with the result of the method or an Error.
     */
    async request(method, ...parameters) {
        // If we are not connected to a server..
        if (this.connection.status !== exports.ConnectionStatus.CONNECTED) {
            // Reject the request with a disconnected error message.
            throw (new Error(`Unable to send request to a disconnected server '${this.connection.host}'.`));
        }
        // Increase the request ID by one.
        this.requestId += 1;
        // Store a copy of the request id.
        const id = this.requestId;
        // Format the arguments as an electrum request object.
        const message = ElectrumProtocol.buildRequestObject(method, parameters, id);
        // Define a function to wrap the request in a promise.
        const requestResolver = (resolve) => {
            // Add a request resolver for this promise to the list of requests.
            this.requestResolvers[id] = (error, data) => {
                // If the resolution failed..
                if (error) {
                    // Resolve the promise with the error for the application to handle.
                    resolve(error);
                }
                else {
                    // Resolve the promise with the request results.
                    resolve(data);
                }
            };
            // Send the request message to the remote server.
            this.connection.send(message);
        };
        // Write a log message.
        debug.network(`Sending request '${method}' to '${this.connection.host}'`);
        // return a promise to deliver results later.
        return new Promise(requestResolver);
    }
    /**
     * Subscribes to the method at the server and attaches the callback function to the event feed.
     *
     * @param {function}  callback     a function that should get notification messages.
     * @param {string}    method       one of the subscribable methods the server supports.
     * @param {...string} parameters   one or more parameters for the method.
     *
     * @throws {Error} if the client is disconnected.
     * @returns a promise resolving to true when the subscription is set up.
     */
    async subscribe(callback, method, ...parameters) {
        // Define a function resolve the subscription setup process.
        const subscriptionResolver = async (resolve) => {
            // If this method is not yet being listened on with this callback..
            if (!this.listeners(method).includes(callback)) {
                // Set up event listener for this subscription.
                this.addListener(method, callback);
            }
            // If this method has never been subscribed to before..
            if (!this.subscriptionMethods[method]) {
                // Initialize an empty subscription payload list for this method.
                this.subscriptionMethods[method] = [];
            }
            // Store the subscription parameters to track what data we have subscribed to.
            this.subscriptionMethods[method].push(JSON.stringify(parameters));
            // Get the currently subscribed payloads for this callback, or an empty array if none exist.
            const subscriptionCallbackPayloads = this.subscriptionCallbacks.get(callback) || [];
            // Update the subscription parameters to track what data this callback is listening on.
            subscriptionCallbackPayloads.push({ method, payload: JSON.stringify(parameters) });
            // Store the subscription parameters.
            this.subscriptionCallbacks.set(callback, subscriptionCallbackPayloads);
            // Send initial subscription request.
            const requestData = await this.request(method, ...parameters);
            // Manually send the initial request data to the callback.
            callback(requestData);
            // Resolve the subscription promise.
            resolve(true);
        };
        // Return a promise that resolves when the subscription is set up.
        return new Promise(subscriptionResolver);
    }
    /**
     * Unsubscribes to the method at the server and removes any callback functions
     * when there are no more subscriptions for the method.
     *
     * @param {function}  callback     a function that has previously been subscribed for this method.
     * @param {string}    method       a previously subscribed to method.
     * @param {...string} parameters   one or more parameters for the method.
     *
     * @throws {Error} if no subscriptions exist for the combination of the passed `callback`, `method` and `parameters.
     * @throws {Error} if the client is disconnected.
     * @returns a promise that resolves to true when the subscription has been cancelled.
     */
    async unsubscribe(callback, method, ...parameters) {
        // Throw an error if the client is disconnected.
        if (this.connection.status !== exports.ConnectionStatus.CONNECTED) {
            throw (new Error(`Unable to send unsubscribe request to a disconnected server '${this.connection.host}'.`));
        }
        // Define a function resolve the subscription setup process.
        const subscriptionResolver = async (resolve) => {
            // Pack up the parameters as a long string.
            const subscriptionParameters = JSON.stringify(parameters);
            // If this method has no subscriptions..
            if (!this.subscriptionMethods[method]) {
                // Reject this promise with an explanation.
                throw (new Error(`Cannot unsubscribe from '${method}' since the method has no subscriptions.`));
            }
            // If this callback has no subscriptions..
            if (!this.subscriptionCallbacks.has(callback)) {
                // Reject this promise with an explanation.
                throw (new Error(`Cannot unsubscribe with '${callback.name}' since the callback has no subscriptions.`));
            }
            // Count the number of methods subscribed to this payload.
            const serverMethodPayloadCount = Object.values(this.subscriptionMethods[method])
                .filter((payload) => payload === subscriptionParameters).length;
            // Count the number of callbacks attached to this method.
            const callbackMethodPayloadCount = (this.subscriptionCallbacks.get(callback) || [])
                .filter((value) => value.method === method).length;
            // Locate the method and callback subscription index.
            const serverMethodPayloadIndex = this.subscriptionMethods[method].indexOf(subscriptionParameters);
            const callbackMethodPayloadIndex = (this.subscriptionCallbacks.get(callback) || [])
                .findIndex((value) => (value.method === method && value.payload === subscriptionParameters));
            // If the method payload could not be located..
            if (serverMethodPayloadIndex < 0) {
                // Reject this promise with an explanation.
                throw (new Error(`Cannot unsubscribe from '${method}' since it has no subscription with the given parameters.`));
            }
            // If the callback payload could not be located..
            if (callbackMethodPayloadIndex < 0) {
                // Reject this promise with an explanation.
                throw (new Error(`Cannot unsubscribe with '${callback.name}' since it has no subscription with the given method and parameters.`));
            }
            // If this is the last payload that any callback has for this method..
            if (serverMethodPayloadCount === 1) {
                // Remove this specific subscription payload from internal tracking.
                this.subscriptionMethods[method].splice(serverMethodPayloadIndex, 1);
                // If the subscription conforms to expected naming standards..
                if (method.endsWith('.subscribe')) {
                    // Send unsubscription request to the server.
                    await this.request(method.replace('.subscribe', '.unsubscribe'), ...parameters);
                }
            }
            // If this is the last payload that this specific callback has to this method..
            if (callbackMethodPayloadCount === 1) {
                // Remove the current callback from listening to given method.
                this.removeListener(method, callback);
            }
            // Get the currently subscribed payloads for this callback, or an empty array if none exist.
            const subscriptionCallbackPayloads = this.subscriptionCallbacks.get(callback) || [];
            // Remove the internal tracking of this callbacks specific method and payload combination.
            this.subscriptionCallbacks.set(callback, subscriptionCallbackPayloads.splice(callbackMethodPayloadIndex, 1));
            // Write a log message.
            debug.client(`Unsubscribed callback '${callback.name}' from '${String(method)}' for the '${subscriptionParameters}' parameters.`);
            // Resolve the subscription promise.
            resolve(true);
        };
        // Return a promise that resolves when the subscription is torn down.
        return new Promise(subscriptionResolver);
    }
    /**
     * Restores existing subscriptions without updating status or triggering manual callbacks.
     *
     * @throws {Error} if subscription data cannot be found for all stored event names.
     * @throws {Error} if the client is disconnected.
     * @returns a promise resolving to true when the subscriptions are restored.
     *
     * @ignore
     */
    async resubscribeOnConnect() {
        // Write a log message.
        debug.client(`Connected to '${this.connection.hostIdentifier}'.`);
        // For each method we have a listener for..
        for (const method of this.eventNames()) {
            // Ignore the connected, disconnected and error method/signals..
            if (method === 'connected' || method === 'disconnected' || method === 'error') {
                continue;
            }
            // Check that we really have a subscription to restore.
            if (!this.subscriptionMethods[String(method)]) {
                // Throw an error since this breaks our expectations.
                throw (new Error(`Unable to resubscribe to ${String(method)} at ${this.connection.hostIdentifier} due to missing subscription data.`));
            }
            // .. and for each parameter we have previously been subscribed to..
            for (const parameterJSON of this.subscriptionMethods[String(method)]) {
                // restore the parameters from JSON.
                const parameters = JSON.parse(parameterJSON);
                // Send a subscription request.
                await this.request(String(method), ...parameters);
            }
            // Write a log message.
            debug.client(`Restored ${this.subscriptionMethods[String(method)].length} previous '${String(method)}' subscriptions for '${this.connection.hostIdentifier}'`);
        }
        // Resolve the subscription promise.
        return true;
    }
    /**
     * Parser messages from the remote server to resolve request promises and emit subscription events.
     *
     * @param {RPCNotification | RPCResponse} message   the response message
     *
     * @throws {Error} if the message ID does not match an existing request.
     * @ignore
     */
    response(message) {
        // If the received message is a notification, we forward it to all event listeners
        if (isRPCNotification(message)) {
            // Write a log message.
            debug.client(`Received notification for '${message.method}' from '${this.connection.host}'`);
            // Forward the message content to all event listeners.
            this.emit(message.method, message.params);
            // Return since it does not have an associated request resolver
            return;
        }
        // If the response ID is null we cannot use it to index our request resolvers
        if (message.id === null) {
            // Throw an internal error, this should not happen.
            throw (new Error('Internal error: Received an RPC response with ID null.'));
        }
        // Look up which request promise we should resolve this.
        const requestResolver = this.requestResolvers[message.id];
        // If we do not have a request resolver for this response message..
        if (!requestResolver) {
            // Throw an internal error, this should not happen.
            throw (new Error('Internal error: Callback for response not available.'));
        }
        // Remove the promise from the request list.
        delete this.requestResolvers[message.id];
        // If the message contains an error..
        if (isRPCErrorResponse(message)) {
            // Forward the message error to the request resolver and omit the `result` parameter.
            requestResolver(new Error(message.error.message));
        }
        else {
            // Forward the message content to the request resolver and omit the `error` parameter
            // (by setting it to undefined).
            requestResolver(undefined, message.result);
        }
    }
    /**
     * Callback function that is called when connection to the Electrum server is lost.
     * Aborts all active requests with an error message indicating that connection was lost.
     *
     * @ignore
     */
    onConnectionDisconnect() {
        // Emit a disconnection signal to any listeners.
        this.emit('disconnected');
        // Loop over active requests
        for (const resolverId in this.requestResolvers) {
            // Extract request resolver for readability
            const requestResolver = this.requestResolvers[resolverId];
            // Resolve the active request with an error indicating that the connection was lost.
            requestResolver(new Error('Connection lost'));
            // Remove the promise from the request list.
            delete this.requestResolvers[resolverId];
        }
    }
}

/**
 * Triggers when the cluster connects to enough servers to satisfy both the cluster confidence and distribution policies.
 *
 * @event ElectrumCluster#ready
 */
/**
 * Triggers when the cluster loses a connection and can no longer satisfy the cluster distribution policy.
 *
 * @event ElectrumCluster#degraded
 */
/**
 * Triggers when the cluster loses a connection and can no longer satisfy the cluster confidence policy.
 *
 * @event ElectrumCluster#disabled
 */
/**
 * High-level electrum client that provides transparent load balancing, confidence checking and/or low-latency polling.
 */
class ElectrumCluster extends events.EventEmitter {
    application;
    version;
    timeout;
    pingInterval;
    // Declare instance variables
    strategy;
    // Initialize an empty dictionary of clients in the cluster
    clients = {};
    // Start at 0 connected clients
    connections = 0;
    // Set up an empty set of notification data.
    notifications = {};
    // Start the cluster in DISABLED state
    status = exports.ClusterStatus.DISABLED;
    // Start counting request IDs at 0
    requestCounter = 0;
    // Initialize an empty dictionary for keeping track of request resolvers
    requestPromises = {};
    // Lock to prevent concurrency race conditions when sending requests.
    requestLock = new asyncMutex.Mutex();
    // Lock to prevent concurrency race conditions when receiving responses.
    responseLock = new asyncMutex.Mutex();
    /**
     * @param {string} application    your application name, used to identify to the electrum hosts.
     * @param {string} version        protocol version to use with the hosts.
     * @param {number} confidence     wait for this number of hosts to provide identical results.
     * @param {number} distribution   request information from this number of hosts.
     * @param {ClusterOrder} order    select hosts to communicate with in this order.
     * @param {number} timeout        how long network delays we will wait for before taking action, in milliseconds.
     * @param {number} pingInterval      the time between sending pings to the electrum host, in milliseconds.
     */
    constructor(application, version, confidence = DefaultParameters.CLUSTER_CONFIDENCE, distribution = DefaultParameters.CLUSTER_DISTRIBUTION, order = DefaultParameters.CLUSTER_ORDER, timeout = DefaultParameters.TIMEOUT, pingInterval = DefaultParameters.PING_INTERVAL) {
        // Initialize the event emitter.
        super();
        this.application = application;
        this.version = version;
        this.timeout = timeout;
        this.pingInterval = pingInterval;
        // Initialize strategy.
        this.strategy =
            {
                distribution: distribution,
                confidence: confidence,
                order: order,
            };
        // Write a log message.
        debug.cluster(`Initialized empty cluster (${confidence} of ${distribution || 'ALL'})`);
        // Print out a warning if we cannot guarantee consensus for subscription notifications.
        // Case 1: we don't know how many servers will be used, so warning just to be safe
        // Case 2: we know the number of servers needed to trust a response is less than 50%.
        if ((distribution === exports.ClusterDistribution.ALL) || (confidence / distribution <= 0.50)) {
            debug.warning(`Subscriptions might return multiple valid responses when confidence (${confidence}) is less than 51% of distribution.`);
        }
    }
    /**
     * Adds a server to the cluster.
     *
     * @param {string} host              fully qualified domain name or IP number of the host.
     * @param {number} port              the TCP network port of the host.
     * @param {TransportScheme} scheme   the transport scheme to use for connection
     * @param {boolean} autoConnect      flag indicating whether the server should automatically connect (default true)
     *
     * @throws {Error} if the cluster's version is not a valid version string.
     * @returns a promise that resolves when the connection has been initiated.
     */
    async addServer(host, port = DefaultParameters.PORT, scheme = DefaultParameters.TRANSPORT_SCHEME, autoConnect = true) {
        // Set up a new electrum client.
        const client = new ElectrumClient(this.application, this.version, host, port, scheme, this.timeout, this.pingInterval);
        // Store this client.
        this.clients[`${host}:${port}`] =
            {
                state: exports.ClientState.UNAVAILABLE,
                connection: client,
            };
        /**
         * Define a helper function to evaluate and log cluster status.
         *
         * @fires ElectrumCluster#ready
         * @fires ElectrumCluster#degraded
         * @fires ElectrumCluster#disabled
         */
        const updateClusterStatus = () => {
            // Calculate the required distribution, taking into account that distribution to all is represented with 0.
            const distribution = Math.max(this.strategy.confidence, this.strategy.distribution);
            // Check if we have enough connections to saturate distribution.
            if (this.connections >= distribution) {
                // If the cluster is not currently considered ready..
                if (this.status !== exports.ClusterStatus.READY) {
                    // Mark the cluster as ready.
                    this.status = exports.ClusterStatus.READY;
                    // Emit the ready signal to indicate the cluster is running in a ready mode.
                    this.emit('ready');
                    // Write a log message with an update on the current cluster status.
                    debug.cluster(`Cluster status is ready (currently ${this.connections} of ${distribution} connections available.)`);
                }
            }
            // If we still have enough available connections to reach confidence..
            else if (this.connections >= this.strategy.confidence) {
                // If the cluster is not currently considered degraded..
                if (this.status !== exports.ClusterStatus.DEGRADED) {
                    // Mark the cluster as degraded.
                    this.status = exports.ClusterStatus.DEGRADED;
                    // Emit the degraded signal to indicate the cluster is running in a degraded mode.
                    this.emit('degraded');
                    // Write a log message with an update on the current cluster status.
                    debug.cluster(`Cluster status is degraded (only ${this.connections} of ${distribution} connections available.)`);
                }
            }
            // If we don't have enough connections to reach confidence..
            // .. and the cluster is not currently considered disabled..
            else if (this.status !== exports.ClusterStatus.DISABLED) {
                // Mark the cluster as disabled.
                this.status = exports.ClusterStatus.DISABLED;
                // Emit the degraded signal to indicate the cluster is disabled.
                this.emit('disabled');
                // Write a log message with an update on the current cluster status.
                debug.cluster(`Cluster status is disabled (only ${this.connections} of the ${distribution} connections are available.)`);
            }
        };
        // Define a function to run when client has connects.
        const onConnect = async () => {
            // Wrap in a try-catch so we can ignore errors.
            try {
                // Check connection status
                const connectionStatus = client.connection.status;
                // If the connection is fine..
                if (connectionStatus === exports.ConnectionStatus.CONNECTED) {
                    // If this was from an unavailable connection..
                    if (this.clients[`${host}:${port}`].state === exports.ClientState.UNAVAILABLE) {
                        // Update connection counter.
                        this.connections += 1;
                    }
                    // Set client state to available.
                    this.clients[`${host}:${port}`].state = exports.ClientState.AVAILABLE;
                    // update the cluster status.
                    updateClusterStatus();
                }
            }
            catch (error) {
                // Do nothing.
            }
        };
        // Define a function to run when client disconnects.
        const onDisconnect = () => {
            // If this was from an established connection..
            if (this.clients[`${host}:${port}`].state === exports.ClientState.AVAILABLE) {
                // Update connection counter.
                this.connections -= 1;
            }
            // Set client state to unavailable.
            this.clients[`${host}:${port}`].state = exports.ClientState.UNAVAILABLE;
            // update the cluster status.
            updateClusterStatus();
        };
        // Set up handlers for connection and disconnection.
        client.connection.on('connect', onConnect.bind(this));
        client.connection.on('disconnect', onDisconnect.bind(this));
        // Connect if auto-connect is set to true, returning the connection result.
        if (autoConnect) {
            // Set up the connection.
            await client.connect();
        }
    }
    /**
     * Calls a method on the remote server with the supplied parameters.
     *
     * @param {string}    method       name of the method to call.
     * @param {...string} parameters   one or more parameters for the method.
     *
     * @throws {Error} if not enough clients are connected
     * @throws {Error} if no response is received with sufficient integrity
     * @returns a promise that resolves with the result of the method.
     */
    async request(method, ...parameters) {
        // Check if the cluster is unable to serve requests.
        if (this.status === exports.ClusterStatus.DISABLED) {
            throw (new Error(`Cannot request '${method}' when available clients (${this.connections}) is less than required confidence (${this.strategy.confidence}).`));
        }
        // Lock this request method temporarily.
        const unlock = await this.requestLock.acquire();
        // Declare requestId outside of try-catch scope.
        let requestId = 0;
        // NOTE: If this async method is called very rapidly, it's theoretically possible that the parts below could interfere.
        try {
            // Increase the current request counter.
            this.requestCounter += 1;
            // Copy the request counter so we can work with the copy and know it won't change
            // even if the request counter is raised from concurrent requests.
            requestId = this.requestCounter;
        }
        finally {
            // Unlock this request method now that the concurrency sensitive condition is completed.
            unlock();
        }
        // Initialize an empty list of request promises.
        this.requestPromises[requestId] = [];
        // Extract all available client IDs
        const availableClientIDs = Object.keys(this.clients)
            .filter((clientID) => this.clients[clientID].state === exports.ClientState.AVAILABLE);
        // Initialize a sent counter.
        let sentCounter = 0;
        // Determine the number of clients we need to send to, taking ClusterDistribution.ALL (=0) into account.
        let requiredDistribution = (this.strategy.distribution || availableClientIDs.length);
        // If the cluster is in degraded status, we do not have enough available clients to
        // match distribution, but still enough to reach consensus, so we use the clients we have.
        if (this.status === exports.ClusterStatus.DEGRADED) {
            requiredDistribution = availableClientIDs.length;
        }
        // Repeat until we have sent the request to the desired number of clients.
        while (sentCounter < requiredDistribution) {
            // Pick an array index according to our ordering strategy.
            let currentIndex = 0;
            // Use a random array index when cluster order is set to RANDOM
            if (this.strategy.order === exports.ClusterOrder.RANDOM) {
                currentIndex = Math.floor(Math.random() * availableClientIDs.length);
            }
            // Move a client identity from the client list to its own variable.
            const [currentClient] = availableClientIDs.splice(currentIndex, 1);
            // Send the request to the client and store the request promise.
            const requestPromise = this.clients[currentClient].connection.request(method, ...parameters);
            this.requestPromises[requestId].push(requestPromise);
            // Increase the sent counter.
            sentCounter += 1;
        }
        // Define a function to poll for request responses.
        const pollResponse = (resolve, reject) => {
            // Define a function to resolve request responses based on integrity.
            const resolveRequest = async () => {
                // Set up an empty set of response data.
                const responseData = {};
                // Set up a counter to keep track of how many responses we have checked.
                let checkedResponses = 0;
                // For each server we issued a request to..
                for (const currentPromise in this.requestPromises[requestId]) {
                    // Race the request promise against a pre-resolved request to determine promise status.
                    const promises = [this.requestPromises[requestId][currentPromise], Promise.resolve(undefined)];
                    const response = await Promise.race(promises);
                    // If the promise is settled..
                    if (response !== undefined) {
                        // Calculate a unique identifier for this notification data.
                        const responseDataIdentifier = JSON.stringify(response);
                        // Increase the counter for checked responses.
                        checkedResponses += 1;
                        // Either set the response data counter or increase it.
                        if (responseData[responseDataIdentifier] === undefined) {
                            responseData[responseDataIdentifier] = 1;
                        }
                        else {
                            responseData[responseDataIdentifier] += 1;
                        }
                        // Check if this response has enough integrity according to our confidence strategy.
                        if (responseData[responseDataIdentifier] === this.strategy.confidence) {
                            // Write log entry.
                            debug.cluster(`Validated response for '${method}' with sufficient integrity (${this.strategy.confidence}).`);
                            // Resolve the request with this response.
                            resolve(response);
                            // Return after resolving since we do not want to continue the execution.
                            return;
                        }
                    }
                }
                // If all clients have responded but we failed to reach desired integrity..
                if (checkedResponses === this.requestPromises[requestId].length) {
                    // Reject this request with an error message.
                    reject(new Error(`Unable to complete request for '${method}', response failed to reach sufficient integrity (${this.strategy.confidence}).`));
                    // Return after rejecting since we do not want to continue the execution.
                    return;
                }
                // If we are not ready, but have not timed out and should wait more..
                setTimeout(resolveRequest, 1000);
            };
            // Attempt the initial resolution of the request.
            resolveRequest();
        };
        // return some kind of promise that resolves when integrity number of clients results match.
        return new Promise(pollResponse);
    }
    /**
     * Subscribes to the method at the cluster and attaches the callback function to the event feed.
     *
     * @param {function}  callback     a function that should get notification messages.
     * @param {string}    method       one of the subscribable methods the server supports.
     * @param {...string} parameters   one or more parameters for the method.
     *
     * @throws {Error} if not enough clients are connected
     * @throws {Error} if no response is received with sufficient integrity for the initial request
     * @returns a promise resolving to true when the subscription is set up.
     */
    async subscribe(callback, method, ...parameters) {
        // Define a function resolve the subscription setup process.
        const subscriptionResolver = async (resolve) => {
            // Define a callback function to validate server notifications and pass
            // them to the subscribe callback.
            const subscriptionResponder = async (data) => {
                // Lock this response method temporarily.
                const unlock = await this.responseLock.acquire();
                try {
                    // Calculate a unique identifier for this notification data.
                    const responseDataIdentifier = JSON.stringify(data);
                    // Either set the notification counter or increase it.
                    if (this.notifications[responseDataIdentifier] === undefined) {
                        this.notifications[responseDataIdentifier] = 1;
                    }
                    else {
                        this.notifications[responseDataIdentifier] += 1;
                    }
                    // Check if this notification has enough integrity according to our confidence strategy.
                    if (this.notifications[responseDataIdentifier] === this.strategy.confidence) {
                        // Write log entry.
                        debug.cluster(`Validated notification for '${method}' with sufficient integrity (${this.strategy.confidence}).`);
                        // Send the notification data to the callback function.
                        callback(data);
                    }
                }
                finally {
                    // Unlock the response method so it can handle the next set of data.
                    unlock();
                }
            };
            // Set up event listener for this subscription.
            for (const currentClient in this.clients) {
                // Copy the current client for brevity.
                const client = this.clients[currentClient].connection;
                // If this method is not yet being listened on..
                if (!client.listeners(method).includes(subscriptionResponder)) {
                    // Set up event listener for this subscription.
                    client.addListener(method, subscriptionResponder);
                }
                // If this method has never been subscribed to before..
                if (!client.subscriptionMethods[method]) {
                    // Initialize an empty subscription payload list for this method.
                    client.subscriptionMethods[method] = [];
                }
                // Store the subscription parameters to track what data we have subscribed to.
                client.subscriptionMethods[method].push(JSON.stringify(parameters));
                // Get the currently subscribed payloads for this callback, or an empty array if none exist.
                const subscriptionCallbackPayloads = client.subscriptionCallbacks.get(callback) || [];
                // Update the subscription parameters to track what data this callback is listening on.
                subscriptionCallbackPayloads.push({ method, payload: JSON.stringify(parameters) });
                // Store the subscription parameters.
                client.subscriptionCallbacks.set(callback, subscriptionCallbackPayloads);
            }
            // Send initial subscription request.
            const requestData = await this.request(method, ...parameters);
            // Manually send the initial request data to the callback.
            callback(requestData);
            // Resolve the subscription promise.
            resolve(true);
        };
        // Return a promise that resolves when the subscription is set up.
        return new Promise(subscriptionResolver);
    }
    /**
     * Unsubscribes to the method at the cluster and removes any callback functions
     * when there are no more subscriptions for the method.
     *
     * @param {function}  callback     a function that has previously been subscribed for this method.
     * @param {string}    method       one of the subscribable methods the server supports.
     * @param {...string} parameters   one or more parameters for the method.
     *
     * @throws {Error} if, for any of the clients, no subscriptions exist for the combination of the
     * passed `callback`, `method` and `parameters.
     * @returns a promise resolving to true when the subscription has been cancelled.
     */
    async unsubscribe(callback, method, ...parameters) {
        // Define a function resolve the subscription setup process.
        const subscriptionResolver = async (resolve) => {
            // For each client..
            for (const currentClient in this.clients) {
                // Store client in variable for brevity
                const client = this.clients[currentClient].connection;
                // Log a warning if one of the clients is disconnected, but don't throw an error
                if (client.connection.status !== exports.ConnectionStatus.CONNECTED) {
                    debug.warning(`Client with server ${client.connection.host} could not be reached to unsubscribe`);
                    continue;
                }
                // unsubscribe this client.
                client.unsubscribe(callback, method, ...parameters);
            }
            // Resolve the subscription promise.
            resolve(true);
        };
        // Return a promise that resolves when the subscription is set up.
        return new Promise(subscriptionResolver);
    }
    /**
     * Provides a method to check or wait for the cluster to become ready.
     *
     * @returns a promise that resolves when the required servers are available.
     */
    async ready() {
        // Store the current timestamp.
        const readyTimestamp = Date.now();
        // Define a function to poll for availability of the cluster.
        const availabilityPoller = (resolve) => {
            // Define a function to check if the cluster is ready to be used.
            const connectionAvailabilityVerifier = () => {
                // Check if the cluster is active..
                if (this.status === exports.ClusterStatus.READY) {
                    // Resolve with true to indicate that the cluster is ready to use.
                    resolve(true);
                    // Return after resolving since we do not want to continue the execution.
                    return;
                }
                // Calculate how long we have waited, in milliseconds.
                const timeWaited = (Date.now() - readyTimestamp);
                // Check if we have waited longer than our timeout setting.
                if (timeWaited > this.timeout) {
                    // Resolve with false to indicate that we did not get ready in time.
                    resolve(false);
                    // Return after resolving since we do not want to continue the execution.
                    return;
                }
                // If we are not ready, but have not timed out and should wait more..
                setTimeout(connectionAvailabilityVerifier, 50);
            };
            // Run the initial verification.
            connectionAvailabilityVerifier();
        };
        // Return a promise that resolves when the available clients is sufficient.
        return new Promise(availabilityPoller);
    }
    /**
     * Connects all servers from the cluster and attaches event listeners and handlers
     * for all underlying clients and connections.
     *
     * @throws {Error} if the cluster's version is not a valid version string.
     */
    async startup() {
        // Write a log message.
        debug.cluster('Starting up cluster.');
        // Keep track of all connections
        const connections = [];
        // Loop over all clients and reconnect them if they're disconnected
        for (const clientKey in this.clients) {
            // Retrieve connection information for the client
            const { host, port, scheme } = this.clients[clientKey].connection.connection;
            // Only connect currently unavailable/disconnected clients
            if (this.clients[clientKey].state === exports.ClientState.AVAILABLE) {
                // Warn when a server is already connected when calling startup()
                debug.warning(`Called startup(), but server ${host}:${port} is already connected`);
            }
            else {
                // Call the addServer() function with the existing connection data
                // This effectively reconnects the server and re-instates all event listeners
                connections.push(this.addServer(host, port, scheme));
            }
        }
        // Await all connections
        return Promise.all(connections);
    }
    /**
     * Disconnects all servers from the cluster. Removes all event listeners and
     * handlers from all underlying clients and connections. This includes all
     * active subscriptions, unless retainSubscriptions is set to true.
     *
     * @param {boolean} retainSubscriptions   retain subscription data so they will be restored on reconnection.
     *
     * @returns a list with the disconnection result for every client
     */
    async shutdown(retainSubscriptions = false) {
        // Write a log message.
        debug.cluster('Shutting down cluster.');
        // Set up a list of disconnections to wait for.
        const disconnections = [];
        const disconnectResolver = (resolve) => {
            // Resolve once the cluster is marked as disabled
            this.once('disabled', () => resolve(Promise.all(disconnections)));
            // For each client in this cluster..
            for (const clientIndex in this.clients) {
                // Force disconnection regardless of current status.
                disconnections.push(this.clients[clientIndex].connection.disconnect(true, retainSubscriptions));
            }
        };
        // Return a list of booleans indicating disconnections from all clients
        return new Promise(disconnectResolver);
    }
}

exports.DefaultParameters = DefaultParameters;
exports.ElectrumClient = ElectrumClient;
exports.ElectrumCluster = ElectrumCluster;
exports.ElectrumTransport = ElectrumTransport;
exports.isVersionNegotiated = isVersionNegotiated;
exports.isVersionRejected = isVersionRejected;
