export declare const Op: typeof import("@bitauth/libauth").OpcodesBCH2023;
export type Op = number;
export type OpOrData = Op | Uint8Array;
export type Script = OpOrData[];
export declare function scriptToAsm(script: Script): string;
export declare function scriptToBitAuthAsm(script: Script): string;
export declare function asmToScript(asm: string): Script;
export declare function bitAuthAsmToScript(asm: string): Script;
export declare function scriptToBytecode(script: Script): Uint8Array;
export declare function bytecodeToScript(bytecode: Uint8Array): Script;
export declare function asmToBytecode(asm: string): Uint8Array;
export declare function bytecodeToAsm(bytecode: Uint8Array): string;
export declare function bytecodeToBitAuthAsm(bytecode: Uint8Array): string;
export declare function countOpcodes(script: Script): number;
export declare function calculateBytesize(script: Script): number;
export declare function encodeNullDataScript(chunks: OpOrData[]): Uint8Array;
/**
 * When cutting out the tx.bytecode preimage variable, the compiler does not know
 * the size of the final redeem scrip yet, because the constructor parameters still
 * need to get added. Because of this it does not know whether the VarInt is 1 or 3
 * bytes. During compilation, an OP_NOP is added at the spot where the bytecode is
 * cut out. This function replaces that OP_NOP and adds either 1 or 3 to the cut to
 * additionally cut off the VarInt.
 *
 * @param script incomplete redeem script
 * @returns completed redeem script
 */
export declare function replaceBytecodeNop(script: Script): Script;
export declare function generateRedeemScript(baseScript: Script, encodedConstructorArgs: Script): Script;
export declare function optimiseBytecode(script: Script, runs?: number): Script;
