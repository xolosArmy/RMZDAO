export class ArrayType {
    constructor(elementType, bound) {
        this.elementType = elementType;
        this.bound = bound;
    }
    toString() {
        return `${this.elementType}[${this.bound ?? ''}]`;
    }
}
export class BytesType {
    constructor(bound) {
        this.bound = bound;
    }
    static fromString(str) {
        const bound = str === 'byte' ? 1 : Number.parseInt(str.substring(5), 10) || undefined;
        return new BytesType(bound);
    }
    toString() {
        return `bytes${this.bound ?? ''}`;
    }
}
export class TupleType {
    constructor(elementType) {
        this.elementType = elementType;
    }
    toString() {
        return `(${this.elementType}, ${this.elementType})`;
    }
}
export var PrimitiveType;
(function (PrimitiveType) {
    PrimitiveType["INT"] = "int";
    PrimitiveType["BOOL"] = "bool";
    PrimitiveType["STRING"] = "string";
    // ADDRESS = 'address',
    PrimitiveType["PUBKEY"] = "pubkey";
    PrimitiveType["SIG"] = "sig";
    PrimitiveType["DATASIG"] = "datasig";
    PrimitiveType["ANY"] = "any";
})(PrimitiveType || (PrimitiveType = {}));
const ExplicitlyCastableTo = {
    [PrimitiveType.INT]: [PrimitiveType.INT, PrimitiveType.BOOL],
    [PrimitiveType.BOOL]: [PrimitiveType.BOOL, PrimitiveType.INT],
    [PrimitiveType.STRING]: [PrimitiveType.STRING],
    [PrimitiveType.PUBKEY]: [PrimitiveType.PUBKEY],
    [PrimitiveType.SIG]: [PrimitiveType.SIG],
    [PrimitiveType.DATASIG]: [PrimitiveType.DATASIG],
    [PrimitiveType.ANY]: [],
};
export function explicitlyCastable(from, to) {
    if (!from || !to)
        return false;
    // Tuples can't be cast
    if (from instanceof TupleType || to instanceof TupleType)
        return false;
    // Arrays can be cast if their elements can be cast (don't think this is actually used ever)
    if (from instanceof ArrayType && to instanceof ArrayType) {
        return explicitlyCastable(from.elementType, to.elementType);
    }
    // Can't cast between Array and non-Array
    if (from instanceof ArrayType || to instanceof ArrayType)
        return false;
    if (to instanceof BytesType) {
        // Can't cast bool to bytes
        if (from === PrimitiveType.BOOL)
            return false;
        // Can cast int to any size bytes
        if (from === PrimitiveType.INT)
            return true;
        // Can freely cast to unbounded bytes
        if (!to.bound)
            return true;
        if (from instanceof BytesType) {
            // Can freely cast from unbounded bytes
            if (!from.bound)
                return true;
            // Can only cast bounded bytes to bounded bytes if bounds are equal
            return from.bound === to.bound;
        }
        // Cannot cast other primitive types directly to bounded bytes types
        return false;
    }
    if (from instanceof BytesType) {
        // Can cast unbounded bytes or <=4 bytes to int
        if (to === PrimitiveType.INT)
            return !from.bound || from.bound <= 8;
        // Can't cast bytes to bool or string
        if (to === PrimitiveType.BOOL)
            return false;
        if (to === PrimitiveType.STRING)
            return false;
        // Can cast any bytes to pubkey, sig, datasig
        if (to === PrimitiveType.PUBKEY)
            return true;
        if (to === PrimitiveType.SIG)
            return true;
        if (to === PrimitiveType.DATASIG)
            return true;
        return true;
    }
    return ExplicitlyCastableTo[from].includes(to);
}
export function implicitlyCastable(actual, expected) {
    if (!actual || !expected)
        return false;
    // Tuples can't be cast
    if (actual instanceof TupleType || expected instanceof TupleType)
        return false;
    // Arrays can be cast if their elements can be cast (don't think this is actually used ever)
    if (actual instanceof ArrayType && expected instanceof ArrayType) {
        return implicitlyCastable(actual.elementType, expected.elementType);
    }
    // Can't cast between Array and non-Array
    if (actual instanceof ArrayType || expected instanceof ArrayType)
        return false;
    // Anything can be implicitly cast to ANY
    if (expected === PrimitiveType.ANY)
        return true;
    if (expected instanceof BytesType) {
        // Can't implicitly cast bool, int, string to bytes
        if (actual === PrimitiveType.BOOL)
            return false;
        if (actual === PrimitiveType.INT)
            return false;
        if (actual === PrimitiveType.STRING)
            return false;
        // Can freely cast to unbounded bytes
        if (!expected.bound)
            return true;
        if (actual instanceof BytesType) {
            // Cannot implicitly cast from unbounded bytes
            if (!actual.bound)
                return false;
            // Can only cast bounded bytes to bounded bytes if bounds are equal
            return actual.bound === expected.bound;
        }
        // Cannot cast other primitive types directly to bounded bytes types
        return false;
    }
    // Other primitive types can only be implicitly cast to themselves
    return actual === expected;
}
export function resultingType(left, right) {
    if (implicitlyCastable(left, right))
        return right;
    if (implicitlyCastable(right, left))
        return left;
    if (left instanceof BytesType && right instanceof BytesType) {
        return new BytesType();
    }
    return undefined;
}
export function arrayType(types) {
    if (types.length === 0)
        return undefined;
    let resType = types[0];
    types.forEach((t) => {
        resType = resultingType(resType, t);
    });
    return resType;
}
export function implicitlyCastableSignature(actual, expected) {
    if (actual.length !== expected.length)
        return false;
    return expected.every((t, i) => implicitlyCastable(actual[i], t));
}
export function parseType(str) {
    if (str.startsWith('byte'))
        return BytesType.fromString(str);
    return PrimitiveType[str.toUpperCase()];
}
export function isPrimitive(type) {
    return !!PrimitiveType[type.toString().toUpperCase()];
}
// Denotes whether an opcode belongs to the "start" or "end" of the statement it's in (defaults to "start")
// Examples:
// require(true); --> the OP_VERIFY comes after the condition (OP_TRUE), so it should get a PositionHint.END
// !true --> the OP_NOT comes after the condition (OP_TRUE), so it should get a PositionHint.END
// if (true) { ... } --> the OP_IF comes before the body, so it should get a PositionHint.START,
//                       the OP_ENDIF comes after the body, so it should get a PositionHint.END
export var PositionHint;
(function (PositionHint) {
    PositionHint[PositionHint["START"] = 0] = "START";
    PositionHint[PositionHint["END"] = 1] = "END";
})(PositionHint || (PositionHint = {}));
//# sourceMappingURL=types.js.map